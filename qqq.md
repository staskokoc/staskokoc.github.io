1

Kotlin, Android, GIT, Паттерны, Gradle, Собеседование

В чем разница между val и const (тем, что const переменным нельзя присвоить значение в рантайме?)

Ключевое слово const можно применять только к переменным, которые будут содержать базовые типы данных?

Добавить ещё один способ объявления переменной (val a и var a)

При объявлении переменной, что содержит объект тип переменной указывать обязательно?

В каких случаях обязательно нужно указывать тип переменной?

Добавить главу про null

Добавить главу про let

Добавить главу и описать в ней на каком уровне и что можно, а что нельзя делать

Ввод с консоли:

print(), println(), readLine()

Вопросы:

\* Можно ли объявлять переменные на одной строке как в java?

Наследование. Добавить первый способ наследования с первичным конструктором

Добавить this() описание, что с помощью этой конструкции вызывается первичный или вторичный конструктор

На глобальном уровне можно только объявлять что-то, вызывать или переприсваивать нельзя

Существуют функциональное программирование, объектно ориентированное программирование, обобщённое программирование

Как подключить библиотеку к своему проекту?

Что такое сигнатура?
# Основы языка
## 1 Базовая структура программы
Функция main:

Функция main – точка входа в программу

Синтаксис:

|fun main() {<br>`    `*println*("hello")<br>}|
| :- |

Инструкции и блоки кода:

Инструкция – выполнение некоторого действия в программе (вызов функции, объявление переменной, присваивание значения, объявление класса)

После инструкции необязательно ставить точку с запятой (каждая инструкция размещается на новой строке)

Если инструкции располагаются на одной строке – их нужно разделить точкой с запятой

Блоки кода – набор инструкций, объединенных в один блок {} (например в цикле, условии, функции, классе)

Комментарии:

Комментарии – текст в коде программы, который игнорируется программой (такой текст нужен только для разработчика)

Есть однострочные и многострочные (// и /\* комментарий \*/)
## 2 Базовые типы данных
Список всех базовых типов данных (14): Byte, Short, Int, Long, UByte, UShort, UInt, ULong, Float, Double, Boolean, Char, String, Any


|Тип данных|Размер|Диапазон значений|Суффикс|
| :-: | :-: | :-: | :-: |
|Byte|1 байт|от -128 до 127|нет|
|Short|2 байта|от -32 768 до 32 767|нет|
|Int|4 байта|<p>от -2 147 483 648 (-2^31)</p><p>до 2 147 483 647 ((2^31) - 1)</p>|нет|
|Long|8 байт|<p>от -9 223 372 036 854 775 808 (-2^63)</p><p>до 9 223 372 036 854 775 807 ((2^63) - 1)</p>|L или l|
|UByte|1 байт|от 0 до 255|U или u|
|UShort|2 байта|от 0 до 65 535|U или u|
|UInt|4 байта|0 до (2^32) – 1|U или u|
|ULong|8 байт|0 до (2^64) – 1|U или u|
|Float|4 байта|-3.4\*10^38 до 3.4\*10^38|F или f|
|Double|8 байт|±5.0\*10^-324 до ±1.7\*10^308|D или d|


|Тип данных|Описание|
| :- | :- |
|Boolean|Boolean хранит в себе значения или true, или false|
|Char|<p>Char хранит символы от ‘A’ до ‘Z’, от ‘0’ до ‘9’ (хранит символы Unicode)</p><p>Поддерживает управляющие символы: ‘\t’, ‘\n’, ‘\r’, ‘\’’, ‘\”’, ‘\\’</p>|
|String|<p>String хранит последовательность символов: “слово”</p><p>Поддерживает управляющие символы: ‘\t’, ‘\n’, ‘\r’, ‘\’’, ‘\”’, ‘\\’</p><p>Поддерживает шаблоны строк: “привет $name”, “привет ${bob.name}”</p><p>Поддерживает многострочный текст: “”” многострочный</p><p>`					      `текст “””</p>|
|Any|Any хранит в себе значения любых типов данных|

Число можно определить в двоичной системе: 0bЧИСЛО

Число можно определить в шестнадцатеричной системе: 0xЧИСЛО

Все целочисленные литералы рассматриваются как Int

Все дробные литералы рассматриваются как Double
## 2 Диапазоны
Диапазон – представляет набор значений или некоторый интервал; отдельный тип данных

Диапазоны можно создать только следующих типов IntRange, LongRange, CharRange

По умолчанию используется IntRange

Ключевые слова для диапазонов:

.. – создаёт диапазон по возрастанию:

|val a = 0..10|
| :- |
downTo – создаёт диапазон по убыванию:

|val a = 10 downTo 0|
| :- |
until – похожа на .., но не включает в себя последнее значение

|val a = 0 until 10|
| :- |
step – определяет шаг при создании диапазона (можно употребить после .., downTo, until):

|val a = 0..10 step 2|
| :- |

С помощью оператора in, !in можно проверить наличие значения в диапазоне

С помощью цикла for можно обращаться к значениям диапазона

Как создать диапазон от 0 до 10 и использовать его:

|<p>fun main() {<br>`    `val a = 0..10<br>`    `for(i in a) {<br>`        `*print*("$i ")<br>`    `}<br>}</p><p></p><p>Вывод:</p><p>0 1 2 3 4 5 6 7 8 9 10</p>|
| :- |

Как создать диапазон от 0 до 10 с шагом в 2 и использовать его:

|<p>fun main() {<br>`    `val a = 0..10 *step* 2<br>`    `for(i in a) {<br>`        `*print*("$i ")<br>`    `}<br>}</p><p></p><p>Вывод:</p><p>0 2 4 6 8 10</p>|
| :- |

Как создать диапазон IntRange:

|<p>fun main() {</p><p>`	`val i: IntRange = 0..10</p><p>`	`for(a in i) {</p><p>`		`print("${a} ")</p><p>`	`}</p><p>}</p>|
| :- |

Как создать диапазон LongRange:

|<p>fun main() {</p><p>`	`val l: LongRange = 0..10L</p><p>`	`for(a in l) {</p><p>`		`print("${a} ")</p><p>`	`}</p><p>}</p>|
| :- |

Как создать диапазон CharRange:

|<p>fun main() {</p><p>`	`val c: CharRange = 'a'..'z'</p><p>`	`for(a in c) {</p><p>`		`print("${a} ")</p><p>`	`}</p><p>}</p>|
| :- |

Как проверить наличие значения в диапазоне (in):

|<p>fun main() {</p><p>`	`diapazon()</p><p>}</p><p></p><p>fun diapazon() {</p><p>`	`val a = 0..10</p><p>`	`if (4 in a) println("4 in a")</p><p>}</p><p></p><p>Вывод:</p><p>4 in a</p>|
| :- |

## 3 Переменные
Существует три типа переменных в Kotlin: локальная переменная, свойство класса, глобальная переменная

Поле существует только в свойствах в методах get и set (называется field)

Основное про переменные:

|<p>Переменная – контейнер, который хранит значение</p><p>Свойство – переменная, которая содержит методы get и set</p><p>Локальная переменная - переменная, объявленная в функции или методе</p><p>Свойство класса - переменная, объявленная в классе (не в методе)</p><p>Глобальная переменная - свойство, объявленное на уровне объявления классов</p><p>Константа – переменная, которую невозможно изменить после инициализации</p><p>val – определение константы</p><p>var – обычная переменная</p>|
| :- |
|Тип переменной|Нужно сразу инициализировать после объявления?|Есть методы get и set?|Может быть val или var?|
|Локальная переменная|Нет (важно присвоить значение до использования)|Нет|Да|
|Свойство класса|Да (иначе возникнет ошибка)|Да|Да|
|Глобальная переменная|Да (иначе возникнет ошибка)|Да|Да|

Какими способами можно объявить переменную в контексте функции (локальная переменная):

|<p>fun main() {<br>`    `val a: Int = 1<br>`    `val b: Int<br>`    `val c = 1</p><p>`    `// тип переменной вычисляется автоматически<br>`    `// в зависимости от значения, которое присваивается переменной<br><br>`    `var d: Int = 2<br>`    `var e: Int<br>`    `var f = 2</p><p>`    `// тип переменной вычисляется автоматически<br>`    `// в зависимости от значения, которое присваивается переменной<br><br>}</p>|
| :- |

Какими способами можно объявить переменную в контексте класса (свойство класса):

|class Person() {<br>`    `val a: Int = 1<br>`    `// val b: Int // так делать нельзя<br>`    `val c = 1<br><br>`    `var d: Int = 2<br>`    `// var e: Int // так делать нельзя<br>`    `var f = 2<br>}|
| :- |

Какими способами можно объявить переменную в глобальном контексте (глобальная переменная):

|val *a*: Int = 1<br>// val b: Int // так делать нельзя<br>val *c* = 1<br><br>var *d*: Int = 2<br>// var e: Int // так делать нельзя<br>var *f* = 2|
| :- |

## 3 Геттеры и сеттеры
Основное про геттеры и сеттеры:

|<p>Геттер – показывает значение переменной</p><p>Сеттер – присваивает значение переменной</p><p>field – переменная, которая непосредственно хранит значение свойства (можно не использовать)</p>|<p>Если переопределить сеттер и принимаемый параметр не присваивать полю field, </p><p>то при следующих попытках присваивания значение свойства не будет меняться</p><p>Если переопределить геттер и возвращать в качестве значение не field, </p><p>то в таком случае настоящее значение свойства невозможно будет получить</p><p>Можно переопределить геттер и сеттер одновременно</p>|
| :- | :- |
||Можно определить с помощью одного выражения?|Можно определить с помощью блока кода?|Можно ли использовать return?|Обязательно ли использовать return?|Может принимать входящие параметры?|Обязательно ли должен быть определён входящий параметр?|Входящий параметр может иметь любое имя?|Внутри можно делать что угодно?|Можно ли изменять значение field?|
|get()|Да|Да|Да|Да|Нет|Нет|Нет|Да|<p>Если val, то нет </p><p>(иначе возникнет ошибка)</p>|
|set()|Нет|Да|Да|Нет|Да |Да|Да|Да|<p>Если val, то нет </p><p>(иначе возникнет ошибка)</p>|

Как создать геттер:

|fun main() {<br>`    `*println*(*age*)<br>}<br><br>var *age* = 18<br>`    `get() {<br>`        `return **field**<br>`    `}|
| :- |

Как создать сеттер:

|<p>fun main() {<br>`    `*println*(*age*)<br>`    `*age* = 99<br>`    `*println*(*age*)<br>`    `*age* = 200<br>`    `*println*(*age*)<br>}<br><br>var *age* = 0<br>`    `set(value) {<br>`        `if((value > 0) and (value < 100)) {<br>`            `**field** = value<br>`            `*println*("Значение присвоено")<br>`            `return<br>`        `}<br>`        `*println*("Значение не присвоено")<br>`    `}</p><p></p><p>Вывод:</p><p>0</p><p>Значение присвоено</p><p>99</p><p>Значение не присвоено</p><p>99</p>|
| :- |

Как создать геттер с помощью одного выражения:

|<p>fun main() {</p><p>`	`println(a)</p><p>}</p><p></p><p>var a = 10</p><p>`	`get() = 2 + 2</p><p></p><p>Вывод:</p><p>4</p>|
| :- |

Что если в сеттере не присваивать значение в поле field (в этом примере age всегда будет равна 18):

|<p>fun main() {<br>`    `*println*(*age*)<br>`    `*age* = 99<br>`    `*println*(*age*)<br>`    `*age* = 200<br>`    `*println*(*age*)<br>}<br><br>var *age* = 18<br>`    `set(value) {<br>`        `var a: Int = 1<br>`    `}</p><p></p><p>Вывод:</p><p>18</p><p>18</p><p>18</p>|
| :- |

Что если в геттере не возвращать значение из поля field (в этом примере a всегда будет возвращать число 10):

|<p>fun main() {<br>`    `*println*(*a*)<br>`    `*println*(*a*)<br>`    `*println*(*a*)<br>}<br><br>var *a* = 7<br>`    `get() {<br>`        `return 10<br>`    `}</p><p></p><p>Вывод:</p><p>10</p><p>10</p><p>10</p>|
| :- |

Вопросы:

\* Почему первое присваивание сработало, хотя значение не больше нуля?

Потому что инициализация переменной всегда срабатывает

\* Где можно изменять геттер и сеттер для свойства?

Изменить геттер или сеттер для свойства можно только при объявлении этого свойства
## 3 Массивы
### О массивах
Массив – это объект; совокупность ОДНОТИПНЫХ переменных под одним общим именем

Доступ к конкретному элементу массива осуществляется по его индексу

Могут быть одномерные, многомерные регулярные и многомерные нерегулярные

Как создать одномерный массив (все варианты):

|<p>fun main() {</p><p>`    `var i = 0</p><p>`    `val arrA: Array<Int></p><p>`    `val arrB: Array<Int> = arrayOf(1, 2, 3) </p><p>`    `val arrF: Array<Int> = Array(3, {10}) </p><p>`    `val arrC = arrayOf(1, 2, 3) </p><p>`    `val arrD = Array(3, {5}) </p><p>`    `val arrE = Array(3, {i++}) </p><p></p><p></p><p></p><p></p><p>`    `val arrG: IntArray = intArrayOf(1, 2, 3) </p><p>`    `val arrH: IntArray = IntArray(3, {5}) </p><p>`    `val arrI = intArrayOf(1, 2, 3) </p><p>`    `val arrM = IntArray(3, {5})</p><p>}</p>|<p></p><p></p><p>// явно, без инициализации</p><p>// явно, с инициализацией</p><p>// явно, с инициализацией (размер массива, {значение для каждой ячейки})</p><p>// автоматически, с инициализацией</p><p>// автоматически, с инициализацией (размер массива, {значение для каждой ячейки})</p><p>// автоматически, с инициализацией (размер массива, {значение для каждой ячейки})</p><p></p><p>// Для упрощения создания массива в Kotlin были определены дополнительные типы:</p><p>// BooleanArray, ByteArray, ShortArray, IntArray, LongArray, CharArray, FloatArray, DoubleArray</p><p>// Вместо IntArray может быть указан любой из этих типов</p><p>// явно, с инициализацией</p><p>// явно, с инициализацией (размер массива, {значение для каждой ячейки})</p><p>// автоматически, с инициализацией</p><p>// автоматически, с инициализацией (размер массива, {значение для каждой ячейки})</p>|
| :- | :- |

Как создать многомерный регулярный массив:

|<p>fun main2() {</p><p>`    `var i = 0</p><p>`    `val arrA = Array(3, {Array(3, {i++})})</p><p></p><p>`    `for (a in arrA) {</p><p>`        `for (b in a) {</p><p>`            `print("${b} ")</p><p>`        `}</p><p>`        `println()</p><p>`    `}</p><p>}</p><p></p><p>Вывод:</p><p>0 1 2</p><p>3 4 5</p><p>6 7 8</p>|
| :- |

Как создать многомерный нерегулярный массив:

|<p>fun main2() {</p><p>`    `val arrB = arrayOf(arrayOf(0), arrayOf(1, 2), arrayOf(3, 4, 5))</p><p>    </p><p>`    `for (a in arrB) {</p><p>`        `for (b in a) {</p><p>`            `print("${b} ")</p><p>`        `}</p><p>`        `println()</p><p>`    `}</p><p>}</p><p></p><p>Вывод:</p><p>0</p><p>1 2</p><p>3 4 5</p>|
| :- |

Вопросы:

\* Можно ли в шаблонах использовать диапазоны?

Да, но каждому элементу в массиве будет присвоен диапазон

|<p>fun main() {</p><p>`	`val arr = Array(3, {0..2})</p><p>`	`for (a in arr) {</p><p>`		`for (b in a) {</p><p>`			`print("${b} ")</p><p>`		`}</p><p>`		`println()</p><p>`	`}</p><p>}</p><p>Вывод:</p><p>0 1 2</p><p>0 1 2</p><p>0 1 2</p>|
| :- |
\* Можно ли в переменных с массивами определять геттеры и сеттеры?

Можно, в таком случае в геттере нужно возвращать массив

Сеттер должен принимать массив

Переменная field хранит массив

|<p>fun main() {</p><p>`	`for (a in arr) print("${a} ")</p><p>}</p><p></p><p>var arr = arrayOf(1, 2, 3)</p><p>`	`get() {</p><p>`		`return arrayOf(4, 5, 6)</p><p>`	`}</p><p></p><p>Вывод:</p><p>4 5 6</p>|
| :- |

### val, var и массивы
val – определение константы

var – обычная переменная

var переменная массива позволяет выполнить переприсваивание массива:

|fun main() {<br>`    `// Создали новый массив<br>`    `var myArray = *arrayOf*(1, 2, 3)<br>`    `// Это совершенно новый массив<br>`    `myArray = *arrayOf*(4, 5)<br>}|
| :- |

val переменная массива не позволяет выполнить переприсваивание массива:

|fun main() {<br>`    `// Создали новый массив<br>`    `val myArray = *arrayOf*(1, 2, 3)<br>`    `// Так делать нельзя, возникнет ошибка<br>`    `myArray = *arrayOf*(4, 5)<br>}|
| :- |

Значение элементов массива можно менять и при val, и при var

## 4 Условная конструкция if
### Об if
Блок кода else if и/или else и/или else if можно не писать

Количество else if неограниченно

Условные операторы можно влаживать в друг друга сколько угодно

Как создать условную конструкцию if..else без блока кода:

|fun main() {<br>`    `val a = 3; val b = 2<br><br>`    `if (a > b) *println*("a > b")<br><br>`    `if (a > b) *println*("a > b")<br>`    `else *println*("не знаю ответа")<br><br>`    `if (a > b) *println*("a > b")<br>`    `else if (a < b) *println*("a < b")<br>`    `else if (a == b) *println*("a == b")<br><br>`    `if (a > b) *println*("a > b")<br>`    `else if (a < b) *println*("a < b")<br>`    `else if (a == b) *println*("a == b")<br>`    `else *println*("не знаю ответа")<br>}|
| :- |

Как создать условную конструкцию if..else с блоком кода:

|fun main() {<br>`    `val a = 3; val b = 2<br><br>`    `if (a > b) {<br>`        `*println*("a > b")<br>`    `}<br>`    `/////////////////////////////////////////<br>`    `if (a > b) {<br>`        `*println*("a > b")<br>`    `} else {<br>`        `*println*("не знаю ответа")<br>`    `}<br>`    `/////////////////////////////////////////<br>`    `if (a > b) {<br>`        `*println*("a > b")<br>`    `} else if (a < b) {<br>`        `*println*("a < b")<br>`    `} else if (a == b) {<br>`        `*println*("a == b")<br>`    `}<br>`    `/////////////////////////////////////////<br>`    `if (a > b) {<br>`        `*println*("a > b")<br>`    `} else if (a < b) {<br>`        `*println*("a < b")<br>`    `} else if (a == b) {<br>`        `*println*("a == b")<br>`    `} else {<br>`        `*println*("не знаю ответа")<br>`    `}<br>}|
| :- |

### Возврат значения, тернарный оператор и if
Возвращать результат можно в 3 случаях: при присваивании переменной, при передачи в качестве аргумента, при возврате в качестве результата

Чтобы использовать конструкцию if для того, чтобы возвратить из неё значение, в if обязательно нужно добавить конструкцию else

Если использовать блоки кода, то в конце каждого блока должно быть указано возвращаемое значение

Для возврата значения нельзя использовать ключевое слово return

|fun main() {<br>`    `val a : Int = 5<br>`    `val b : Int = 10<br><br>`    `// с блоками кода<br>`    `var str = if(a > b) {<br>`        `*println*(a)<br>`        `a<br>`    `} else {<br>`        `*println*(b)<br>`        `b<br>`    `}<br>`    `// показать str<br>`    `*println*(str)<br>}|
| :- |

Если не использовать блоки кода, то можно из if..else сделать аналог тернарного оператора:

|fun main() {<br>`    `val a : Int = 5<br>`    `val b : Int = 10<br><br>`    `// без блоков кода (аналог тернарного оператора в Java)<br>`    `var str : Int = if(a > b) a else b<br>`    `*println*(str)<br>`    `// показать str<br>`    `*println*(str)<br>}|
| :- |

Вопросы:

Если не использовать блоки кода, то можно ли возвращать в качестве результата результат какого-либо выражения?

## 4 Условная конструкция when
### Об when
when – проверяет значение некоторого объекта и в зависимости от его значения выполняет тот или иной код

В when можно использовать блоки кода

Как создать условную конструкцию when:

|fun main() {<br>`    `val isEnabled: Boolean = true<br><br>`    `when(isEnabled) {<br>`        `true -> *println*("это включено")<br>`        `false -> *println*("это выключено")<br>`    `}<br>}|
| :- |

Оператор else выполняется, если объект не соответствует ни одному из значений:

|fun main() {<br>`    `val a : Int = 30<br><br>`    `when(a) {<br>`        `10 -> *println*("а = 10")<br>`        `20 -> *println*("а = 20")<br>`        `else -> *println*("неопределённое значение")<br>`    `}<br>}|
| :- |

Можно проверять несколько значений одновременно (нужно указать их через запятую):

|fun main() {<br>`    `val a : Int = 15<br><br>`    `when(a) {<br>`        `10, 15 -> *println*("а = 10 или a = 15")<br>`        `20 -> *println*("а = 20")<br>`        `else -> *println*("неопределённое значение")<br>`    `}<br>}|
| :- |

Можно сравнить с диапазоном чисел:

|fun main() {<br>`    `val a : Int = 15<br><br>`    `when(a) {<br>`        `in 10..15 -> *println*("значение a равно от 10 до 15")<br>`        `20 -> *println*("а = 20")<br>`        `else -> *println*("неопределённое значение")<br>`    `}<br>}|
| :- |
Можно ли сравнить с диапазоном строк? Или символов?

Можно сравнивать с динамически вычисляемым значением:

|fun main() {<br>`    `val a : Int = 30<br>`    `val b : Int = 20<br>`    `val c : Int = 10<br><br>`    `when(a) {<br>`        `b + c -> *println*("a = 30")<br>`        `20 -> *println*("а = 20")<br>`        `else -> *println*("неопределённое значение")<br>`    `}<br>}|
| :- |

when может принимать динамически вычисляемый объект:

|fun main() {<br>`    `val a : Int = 30<br>`    `val b : Int = 20<br>`    `val c : Int = 10<br><br>`    `when(b + c) {<br>`        `30 -> *println*("a = 30")<br>`        `20 -> *println*("а = 20")<br>`        `else -> *println*("неопределённое значение")<br>`    `}<br>}|
| :- |

Можно определить переменные, которые будут доступны внутри блока when:

|<p>fun main() {<br>`    `val a : Int = 30<br>`    `val b : Int = 20<br>`    `val c : Int = 10<br><br>`    `// переменную можно объявить здесь и она будет доступна всем блокам<br>`    `when(val d : Int = b + c) {<br>`        `10 -> *println*("a = 10")<br>`        `20 -> *println*("а = 20")<br>`        `else -> {<br>`            `*println*("d = $d")<br>`            `// переменную можно объявить здесь и она будет <br>`            `// доступна только внутри этого блока<br>`            `val f : Int = 40<br>`            `*println*(f)<br>`        `}<br>`    `}<br>}</p><p></p>|
| :- |

Можно использовать when как альтернативу if..else (в таком случае в проверке должны указываться переменные или выражения только логического типа) (переменная логического типа):

|fun main() {<br>`    `val a : Int = 10<br>`    `val b : Int = 20<br>`    `val c : Boolean = true<br><br>`    `when {<br>`        `c -> *println*("hello")<br>`    `}<br>}|
| :- |

Можно использовать when как альтернативу if..else (в таком случае в проверке должны указываться переменные или выражения только логического типа) (выражение логического типа):

|fun main() {<br>`    `val a : Int = 10<br>`    `val b : Int = 20<br><br>`    `when {<br>`        `(a > b) -> *println*(a)<br>`        `(a < b) -> *println*(b)<br>`    `}<br>}|
| :- |

### Возврат значения и when
Возвращать результат можно в 3 случаях: при присваивании переменной, при передачи в качестве аргумента, при возврате в качестве результата

Чтобы использовать конструкцию when для того, чтобы возвратить значение, в when обязательно нужно добавить конструкцию else

Если использовать блоки кода, то в конце каждого блока должно быть указано возвращаемое значение

Если не использовать блоки кода, то после -> нужно указать возвращаемое значение

Для возврата значения нельзя использовать ключевое слово return

|fun main() {<br>`    `val a : Int = 20<br>`    `val b : Int = 20<br><br>`    `val c : Int = when {<br>`        `(a > b) -> a<br>`        `(a < b) -> b<br>`        `else -> 0<br>`    `}<br>}|
| :- |

Вопросы:

Если не использовать блоки кода, то можно ли возвращать в качестве результата результат какого-либо выражения?

## 4 Цикл while
Циклы бывают с условием и бесконечные

Синтаксис объявления цикла while:

|while(условие) { тело }|
| :- |

Как создать цикл while с условием:

|fun main() {<br>`    `var a: Int = 0; val b: Int = 5<br>`    `while(a < b) {<br>`        `*println*("hello")<br>`        `a++<br>`    `}<br>}|
| :- |

Как создать бесконечный цикл while:

|fun main() {<br>`    `var a: Int = 0; val b: Int = 5<br>`    `while(true) {<br>`        `*println*("hello")<br>`    `}<br>}|
| :- |

Можно ли объявить цикл без условия?

Можно ли объявить цикл без блока кода?
## 4 Цикл for
Цикл for в Kotlin это как foreach в Java

Исп. для последовательного обращения к каждому элементу итерационного объекта

Итерационный объект - объект, к элементам которого можно последовательно обратиться (массив, строка и т.п.)

Синтаксис цикла for:

|for(итр\_пер in ит\_объект) { // что-то делать }|
| :- |

Как создать цикл for:

|fun main() {<br>`    `val str: String = "hello"<br>`    `for(a in str) {<br>`        `*println*(a)<br>`    `}<br>}|
| :- |

Вопросы:

Можно ли использовать for таким же образом как в java?
## 5 Операции
Арифметические операции:

|Операция|Описание|
| :- | :- |
|+|Сложение (а также унарный плюс)|
|-|Вычитание (а также унарный минус)|
|\*|Умножение|
|/|Деление|
|%|Деление по модулю|
|++|Инкремент (приращение на 1)|
|--|Декремент (отрицательное приращение на 1)|
|+=|Сложение с присваиванием|
|-=|Вычитание с присваиванием|
|\*=|Умножение с присваиванием|
|/=|Деление с присваиванием|
|%=|Деление по модулю с присваиванием|

Вопросы:

\* Как работают преинкремент и постинкремент?

++a увеличивается, а затем использует переменную (префиксный инкремент, преинкремент)

a++ использует, а затем увеличивает переменную (постфиксный инкремент, постинкремент)

a++

|<p>fun main() {</p><p>`    `var a: Int = 0</p><p>`    `var b: Int = 0</p><p>`    `println("b = a++")</p><p>`    `println("b = ${a++}")</p><p>}</p><p></p><p>Вывод:</p><p>b = a++</p><p>b = 0</p>|
| :- |

++a

|<p>fun main() {</p><p>`    `var a: Int = 0</p><p>`    `var b: Int = 0</p><p>`    `println("b = ++a")</p><p>`    `println("b = ${++a}")</p><p>}</p><p></p><p>Вывод:</p><p>b = ++a</p><p>b = 1</p>|
| :- |

Поразрядные операции:

Поразрядные операции – операции над отдельными разрядами или битами чисел; операции над каждым битом

В данных операциях в качестве операндов могут выступать только целые числа (9) (Byte, Short, Int, Long, Char, UByte, UShort, UInt, ULong)

Битовые операции используют для увеличения скорости и экономии энергии

По умолчанию, все битовые операции возвращают число в типе данных Int

x and 1 – проверяет чётность числа. Если число четное – результат 0, нечетное – 1; x and y проверить побитово равно ли число x числу y

Все поразрядные операции:

shl – сдвиг битов числа со знаком влево

shr – сдвиг битов числа со знаком вправо

ushr – сдвиг битов беззнакового числа вправо

and – побитовая операци И

or – побитовая операция ИЛИ

xor – побитовая операция ИСКЛЮЧАЮЩЕЕ ИЛИ

inv – инвертирует биты числа

Вопросы:

Существуют ли поразрядные операции с присваиванием?

Все битовые операции возвращают число в типе данных Int?

Зачем нужна операция x and y, если можно проверить равность через if?

Можно ли использовать тип данных Boolean или String в побитовых операциях?

Логические операции:

|Операция|Описание|
| :- | :- |
|!|Логическая унарная операция НЕ (NOT)|
||||Укороченная логическая операция ИЛИ (short-circuit)|
|&&|Укороченная логическая операция И (short-circuit)|

Операции сравнения:

|Операция|Описание|
| :- | :- |
|==|Равно|
|!=|Не равно|
|>|Больше|
|<|Меньше|
|>=|Больше или равно|
|<=|Меньше или равно|
|===|Определяет, ссылаются ли две ссылки на один объект|
|!===|Определяет, не ссылаются ли две ссылки на один объект|
|in|Возвращает true, если операнд имеется в некой последовательности|

Вопросы:

Можно ли эти операции использовать чтобы, например, сравнить два объекта?

Как работают === и !==?

Как работает in?

Пример: a in 1..10
# Функциональное программирование
Функции бывают: функции, функции члены, функции расширения

Добавить описание для каждой функции

Наверное сделать это в отдельной главе

Как возвратить функцию из функции, как передать функцию функции, как присвоить функцию функции

Функция – грубо говоря, метод, который не принадлежит никакому классу (в этом главное отличие функции от метода)
## Однострочная функция
Однострочная функция – функция, блок кода которой может быть выражен одним выражением; функция в одну строку с применением знака равенста

Синтаксис объявления однострочной функции:

|fun имя\_функции(параметры\_функции) = тело\_функции|
| :- |

Как создать однострочную функцию:

|fun main() {<br>`    `*println*(*hello*())<br>}<br><br>fun hello() = "hello"|
| :- |

## Глобальная функция
Глобальная функция – функция, которая определена на глобальном уровне (то есть не вложена ни в какую другую функцию)

Синтаксис объявления обычной функции (возвращаемый тип можно не указывать):

|fun имя\_функции (параметры): возвращаемый\_тип { // тело }|
| :- |

Как создать обычную функцию:

|fun main() {<br>`    `*println*("hello")<br>`    `*hello*()<br>}<br><br>fun hello() {<br>`    `*println*("hello")<br>`    `*println*("hello")<br>}|
| :- |

## Локальная функция
Локальная функция – функция, созданная внутри другой функции

Такая функция может использоваться только в рамках какой-то одной функции

Как создать локальную функцию:

|fun main() {<br>`    `*println*("hello")<br>`    `*hello*()<br>`    `// helloBob() // эта функция недоступна здесь<br>}<br><br>fun hello() {<br>`    `*println*("hello")<br>`    `*println*("hello")<br>`    `fun helloBob() {<br>`        `*println*("hello Bob")<br>`    `}<br>`    `helloBob()<br>}|
| :- |

## Анонимная функция
Анонимные функции выглядят как обычно, только они не имеют имени

Анонимная функция может иметь одно выражение, может иметь блок кода

Анонимную функцию используют только в 3 случаях: присвоить переменной, передать в качестве аргумента, возвратить в качестве результата

Синтаксис создания анонимной функции:

|fun(параметры) { тело }|
| :- |

Как присвоить переменной:

|fun main() {<br>`    `val a = fun() = *println*("hello")<br>`    `a()<br>}|
| :- |

Как присвоить переменной анонимную функцию с параметрами:

|fun main() {<br>`    `val sum = fun(x: Int, y: Int) = *println*(x + y)<br>`    `sum(7, 8)<br>}|
| :- |

Анонимную функцию можно передавать в функцию, если параметр соответствует типу этой функции:

|fun main() {<br>`    `*showHello*(fun() = *println*("hello"))<br>}<br><br>fun showHello(a: () -> Unit) {<br>`    `a()<br>}|
| :- |

Как возвратить в качестве результата:

|fun main() {<br>`    `val action = *selectAction*(1)<br>`    `val result = action(7, 8)<br>`    `*println*(result)<br>}<br><br>fun selectAction(key: Int): (Int, Int) -> Int {<br>`    `when(key){<br>`        `1 -> return fun(x: Int, y: Int): Int = x + y<br>`        `2 -> return fun(x: Int, y: Int): Int = x - y<br>`        `3 -> return fun(x: Int, y: Int): Int = x \* y<br>`        `else -> return fun(x: Int, y: Int): Int = 0<br>`    `}<br>}|
| :- |

## Функция высокого порядка
Функция высокого порядка – функция, которая принимает функцию как параметр, или возвращает функцию в качестве результата, или и то, и другое

Синтаксис создания параметра, который принимает функцию:

|fun имя\_функции(имя\_параметра (параметры\_функции) -> тип\_который\_возвращает\_функция) { тело }|
| :- |

Синтаксис передачи функции в качестве параметра:

|имя\_функции(::имя\_функции)|
| :- |

Синтаксис определения в качестве возвращаемого типа функции:

|fun имя\_функции(параметры): (типы\_параметров\_функции) -> тип\_который\_возвращает\_функция|
| :- |

Как создать функцию высокого порядка (принимает функцию в качестве параметра):

|<p>fun main() {<br>`    `*myFunNormal*(::hello)<br>}<br><br>fun hello() {<br>`    `*println*("hello")<br>}</p><p></p><p>fun myFunNormal(message: () -> Unit) {<br>`    `message()<br>}</p><p></p><p>Вывод:</p><p>Hello</p>|
| :- |

Как создать функцию высокого порядка (возвращает функцию в качестве результата):

|<p>fun main() {<br>`    `var a: () -> Unit = *myFun*() <br>`    `a()<br>}<br><br>fun myFun(): () -> Unit {<br>`    `fun myFunInternal() {<br>`        `*println*("i am myFunInternal()")<br>`    `}<br>`    `return ::myFunInternal<br>}</p><p></p><p>Вывод:</p><p>i am myFunInternal()</p>|
| :- |

Синтаксис создания переменной, которой можно присвоить функцию:

|val\_var имя\_переменной: (типы\_параметров) -> тип\_который\_возвращает\_функция|
| :- |

Синтаксис присваивания переменной функции:

|имя\_переменной = ::имя\_функции|
| :- |

Как создать переменную, которой можно присвоить функцию:

|fun main() {<br>`    `val a: () -> Unit = ::myFun<br>`    `a()<br>}<br><br>fun myFun() {<br>`    `*println*("hello")<br>}|
| :- |

Добавить разные примеры использования

Возможно ли возвратить сразу несколько функций?
## Лямбда выражение
Лямбда выражение – сокращённая запись функции

Лямбда выражение используют только в 4 случаях: в качестве запуска как обычную функцию, присвоить переменной, передать в качестве аргумента, возвратить в качестве результата

Синтаксис создания лямбда выражения:

|{ параметры -> тело }|
| :- |

Синтаксис вызова лямбда выражения (как обычную функцию):

|{ параметры -> тело }()|
| :- |

Как создать лямбда выражение и запустить его как обычную функцию:

|<p>fun main() {<br>`    `*println*("hello");<br>`    `**{** *println*("bye") **}**()<br>}</p><p></p><p>Вывод:</p><p>hello</p><p>bye</p>|
| :- |

Как создать лямбда выражение и запустить его как обычную функцию и сразу передать параметр:

При вызове лямбда выражения как обычную функцию параметры нужно передавать в круглых скобках:

|fun main() {<br>`    `*println*("hello")<br>`    `val a: String = "bye"<br>`    `**{** str: String **->** *println*(str) **}**(a)<br>}|
| :- |

Как лямбду присвоить переменной (без параметров и с параметрами):

|<p>fun main() {<br>`    `*println*("hello")<br>`    `// создание, присваивание и вызов лямбды без параметров<br>`    `val a = **{** *println*("bye") **}**<br>`    `a()<br>`    `// создание, присваивание и вызов лямбды с параметрами<br>`    `val b: (String) -> Unit = **{** str: String **->** *println*(str) **}**<br>`    `b("i am in b")<br>}</p><p></p><p>Вывод:</p><p>hello</p><p>bye</p><p>i am in b</p>|
| :- |

Как возвратить лямбду из функции:

Лямбда выражение, которое мы возвращаем должно совпадать с типом, который возвращает функция 

|fun main() {<br>`    `val action1 = *selectAction*(1)<br>`    `val result1 = action1(7, 8)<br>`    `*println*(result1)<br>}<br><br>fun selectAction(key: Int): (Int, Int) -> Int {<br>`    `when(key){<br>`        `1 -> return **{**x, y **->** x + y**}**<br>`        `2 -> return **{**x, y **->** x - y**}**<br>`        `3 -> return **{**x, y **->** x \* y**}**<br>`        `else -> return **{**x, y **->** 0**}**<br>`    `}<br>}|
| :- |

Как передать лямбду в функцию:

Лямбда выражение, которое мы передаем должно совпадать с типом, который принимает функция

|fun main() {<br>`    `// можно просто передать ссылку на функцию<br>`    `*tom*(::bob, 1)<br>`    `// или можно передать лямбду<br>`    `*tom*(**{** message: String **->** *println*(message) **}**, 1)<br>`    `// или можно передать лямбду другим способом (если не нужны больше никакие другие параметры)<br>`    `*rick* **{** message: String **->** *println*(message) **}**<br>}<br><br>fun tom(message: (String) -> Unit, number: Int) {<br>`    `message("text $number")<br>}<br><br>fun rick(message: (String) -> Unit) {<br>`    `message("text")<br>}<br><br>fun bob(text: String) {<br>`    `*println*(text)<br>}|
| :- |

Синтаксический сахар (типизация параметров лямбды):

При передачи лямбды параметру или переменной, для которых явно указан тип в коде, при реализации лямбды мы можем упустить в лямбда выражении тип параметров:

|fun main() {<br>`    `val sum: (Int, Int) -> Int<br>`    `sum = **{**a, b **->** a + b**}**<br>`    `*println*(sum(7, 8))<br>}|
| :- |

Синтаксический сахар (trailing lambda):

Если параметр, который принимает функцию, является последним в списке параметров, то при передачи ему лямбда выражения, саму лямбду можно прописать после списка параметров:

|fun main() {<br>`    `// можем написать так<br>`    `*doOperation*(7, 8, **{**a, b **->** a \* b**}**)<br>`    `// можем написать так (trailing lambda)<br>`    `*doOperation*(7, 8) **{**a, b **->** a \* b**}**<br>}<br><br>fun doOperation(x: Int, y: Int, op: (Int, Int) -> Int) {<br>`    `val result = op(x, y)<br>`    `*println*(result)<br>}|
| :- |

Синтаксический сахар (прочерк вместо неиспользуемых в теле параметров):

|fun main() {<br>`    `val action1 = *selectAction*(1)<br>`    `val result1 = action1(7, 8)<br>`    `*println*(result1)<br>}<br><br>fun selectAction(key: Int): (Int, Int) -> Int {<br>`    `when(key){<br>`        `1 -> return **{**x, y **->** x + y**}**<br>`        `2 -> return **{**x, y **->** x - y**}**<br>`        `3 -> return **{**x, y **->** x \* y**}**<br>`        `else -> return **{**\_, \_ **->** 0**}**<br>`    `}<br>}|
| :- |

## Ключевое слово return
Чтобы функция возвращала значение нужно после списка параметров через двоеточие указать возвращаемый тип

А в теле функции применить оператор return, после которого указывается возвращаемое значение

Если не указать возвращаемый тип, то при применении оператора return с аргументами возникнет ошибка

Если функция возвращает результат, то необязательно этот результат куда-то присваивать

Синтаксис создания функции с возвращаемым типом:

|fun имя\_функции(параметры): возвращаемый\_тип { // блок кода }|
| :- |

Как возвратить значение из функции:

|fun main() {<br>`    `val str: String;<br>`    `str = *hello*()<br>`    `*println*(str)<br>}<br><br>fun hello(): String {<br>`    `return "hello"<br>}|
| :- |

Если функция не возвращает никакого результата, оператор return всё равно можно использовать без параметров (в качестве оператора, который просто завершает работу функции):

||
| :- |

Тип Unit:

Тип Unit означает, что функция не возвращает никакого результата (аналогично void в Java)

Тип Unit неявно возвращают все функции по умолчанию

Тип Unit можно явно указать как возвращаемый тип (смысла особого в себе это не несёт)

## Перегрузка функции
Перегрузка функции – позволяет объявлять функции с одними и теми же именами, но с различными параметрами

Условия перегрузки функции:

|Параметры перегруженной функции должны отличаться по количеству и/или типу и/или по порядку|
| :- |

Как перегрузить функцию:

|fun main() {<br>`    `*myFun*()<br>`    `*myFun*("bye")<br>}<br>fun myFun() {<br>`    `*println*("hello")<br>}<br>fun myFun(str: String) {<br>`    `*println*(str)<br>}|
| :- |

Вопросы:

Имеет ли значения возвращаемый тип при перегрузки функции?

Отличие в возвращаемом типе не имеет значение

Если функция будет отличаться только по возвращаемому типу, то возникнет ошибка
## Параметры функции
Аргумент - значение, которое мы передаем методу

Параметр - переменная, принимающая аргумент

Параметр по умолчанию – параметр, у которого уже есть значение (по умолчанию)

Именованный параметр – параметр, которому мы аргумент присваиваем по имени этого параметра

Обязательный параметр – параметр, у которого нет значения по умолчанию

Передача значения по позиции – первое значение первому параметру, второе значение второму параметру и т.д.

Передача значения по имени – указываем имя параметра и после знака равно указываем значение, которое хотим передать

Параметры в функциях всегда неявно определены как val (нельзя явно указывать val или var параметр)

Как правильно и неправильно передавать параметры:

|<p>fun main() {<br>`    `// можно передавать значения по порядку<br>`    `*hello*("hello A1", "hello B1", "c", "d")</p><p><br>`    `// можно передать только одно значения по имени, если будет соблюдён порядок<br>`    `*hello*(a = "hello A2", "hello B2", "c", "d")</p><p>`    `// если порядок был нарушен, то и все остальные аргументы нужно передавать по имени<br>`    `// hello(b = "hello B3", "hello A3", "c", "d") // так неправильно<br>`    `*hello*(b = "hello B4", a = "hello A4", c = "C4", d = "D4") // так будет правильно</p><p></p><p>`    `// если сначала стоят параметры по умолчанию, то чтобы передать только</p><p>`    `// обязательные аргументы, нужно передавать их по имени<br>`    `// hello("hello C5", "hello D5") // так неправильно<br>`    `*hello*(c = "hello C6", d = "hello D6") // так будет правильно<br>}<br><br>fun hello(a: String = "hello", b: String = "hello", c: String, d: String) {<br>`    `*println*("$a $b $c $d")<br>}</p>|
| :- |

## Переменное количество параметров
Переменное количество параметров – это конструкция, которая позволяет передавать в функцию сколько угодно аргументов

Синтаксис создания переменного количества параметров:

|fun имя\_функции(vararg имя\_параметра: тип\_параметра) { тело }|
| :- |

Как создать переменное количество параметров и передать их функции:

|fun main() {<br>`    `*hello*(1, 2, 3)<br>`    `*hello*(1)<br>`    `*hello*(1, 2, 3, 4)<br>}<br><br>fun hello(vararg a: Int) {<br>`    `for(i in a) {<br>`        `*println*(i)<br>`    `}<br>}|
| :- |

Как создать переменное количество параметров и после добавить обычный параметр:

|Fun main() {<br>`    `*hello*(1, 2, 3)<br>`    `*hello*(1)<br>`    `*hello*(1, 2, 3, 4)<br>}<br><br>// если обычный параметр указать после переменного количества параметров,<br>// то передать значение обычному параметру можно только по имени<br>fun hello(vararg a: Int, b: Int) {<br>`    `for(i in a) {<br>`        `*println*(i)<br>`    `}<br>}|
| :- |

Как создать переменное количество параметров и перед ними добавить обычный параметр:

|fun main() {<br>`    `*hello*(1, 2, 3)<br>`    `*hello*(1)<br>`    `*hello*(1, 2, 3, 4)<br>}<br><br>// если обычный параметр указать перед переменным количеством параметров,<br>// то первый аргумент будет присвоен обычному параметру, а все последующие<br>// будут присвоены переменному количеству параметров<br>fun hello(b: Int, vararg a: Int) {<br>`    `for(i in a) {<br>`        `*println*(i)<br>`    `}<br>}|
| :- |

Как создать переменное количество параметров и передать ему массив значений (\*):

|fun main() {<br>`    `val arr = *intArrayOf*(1, 2, 3)<br>`    `*hello*(\*arr)<br>}<br><br>fun hello(vararg a: Int) {<br>`    `for(i in a) {<br>`        `*println*(i)<br>`    `}<br>}|
| :- |

## Возврат значения из функции
Чтобы фукнция умела возвращать значение, нужно добавить к её определению специальный синтаксис

Синтаксис возврата значения из функции:

|fun имя\_функции(параметры): возвращаемый тип|
| :- |

Пример:

|fun hello(): String {<br>`    `*println*("hello")<br>`    `return "hello"<br>}|
| :- |

## Вопросы
### Знак =, return и функции
Знак = можно использовать для присваивания значения переменной:

|suspend fun main() {<br>`    `val message: String = "text"<br>}|
| :- |

Знак = можно использовать для присваивания тела функции:

|<p>fun main() {<br>`    `*tom*()<br>}**<br><br>fun tom() = ::bob</p><p><br>fun bob() {<br>`    `*println*("in bob")<br>}</p>|
| :- |

### Знаки ->, () –>, : () -> и функции
-> применяется в случае when и в случае создания лямбды

() -> применяется в случае создания параметра, который принимает функцию

: () -> применяется в случае создания возвращения, которая возвращает функцию
### Функция высокого порядка и лямбда выражение

### Модификаторы и функции
### Области действия и функции
### Ключевые слова и функции
### val, var и функции
Параметры в функциях всегда неявно определены как val (нельзя явно указывать val или var параметр)

# Объектно ориентированное программирование
## Классы и объекты
### О классах (class)
Класс - шаблон, по которому будет составлен объект

Объект - экземпляр класса

Класс должен представлять собой одну логическую сущность

Класс может быть объявлен с конструктором, а может быть объявлен без конструктора

Класс может иметь тело, а может не иметь тела

Какие члены может содержать класс:

Может содержать свойства, методы, конструкторы, инициализаторы

Синтаксис объявления класса:

|class ИмяКласса() { // тело }|
| :- |

Как объявить класс (разные способы):

|class PersonA {} // объявление без конструктора и с телом<br>class PersonB() {} // объявление с конструктором и с телом<br>class PersonC // объявление без конструктора и без тела<br>class PersonD() // объявление с конструктором и без тела|
| :- |

Синтаксис создания объекта класса:

|val имяПеременной: ИмяКласса = ИмяКласса()|
| :- |

Как создать объект класса:

|fun main() {<br>`    `val tom: Person = Person() // первый способ<br>`    `tom.showHello()<br>`    `val jerry = Person() // второй способ<br>`    `jerry.showHello()<br>}<br><br>class Person() {<br>`    `fun showHello() {<br>`        `*println*("hello")<br>`    `}<br>}|
| :- |

### О свойствах
Свойство класса – переменная, объявленная в классе

Свойство класса доступно внутри всего класса

Свойство класса содержит методы get и set

Свойство нужно сразу инициализировать после объявления (иначе возникнет ошибка)

Может быть val или var

Какими способами можно объявить свойство класса:

|class Person() {<br>`    `val a: Int = 1<br>`    `// val b: Int // так делать нельзя<br>`    `val c = 1<br><br>`    `var d: Int = 2<br>`    `// var e: Int // так делать нельзя<br>`    `var f = 2<br>}|
| :- |

### О методах
Метод - отдельный участок кода в классе, который должен выполнять одну логическую задачу

Аргумент - значение, которое мы передаем методу

Параметр - переменная, принимающая аргумент

Как создать метод:

Метод можно создать с параметрами, без параметров 

Метод не может принимать val или var параметры, все параметры в методах всегда неявно определены как val

Можно создать метод, который возвращает значение, а также, который не возвращает значение

|class Person() {<br>`    `// методы, которые не возвращают значение<br>`    `fun myMethA() { *println*() } // метод, не принимает параметров<br>`    `fun myMethB(str: String) { *println*(str) } // метод принимает один параметр<br>`    `fun myMethC(str: String, a: Int) { *println*("$str $a") } // метод принимает два параметра<br>`    `// метод, который возвращает значение<br>`    `fun myMethD(str: String): String {<br>`        `*println*(str)<br>`        `return "$str hello"<br>`    `}<br>}|
| :- |

### О перегрузке методов
Перегрузка метода - это когда в классе написать еще один метод с таким же именем

Новый метод может делать что угодно

Когда происходит перегрузка метода:

Перегрузка происходит тогда, когда имя метода совпадает, но количество и/или порядок параметров и/или их тип отличаются (остальные модификаторы не играют никакой роли)

Как перегрузить метод:

|class Person() {<br>`    `fun myMeth(name: String) {<br>`        `*println*(name)<br>`    `}<br>`    `fun myMeth(name: String, age: Int) {<br>`        `*println*("$name $age")<br>`    `}<br>}|
| :- |

### О конструкторах
Конструктор – отдельный участок кода в классе, который отвечает за инициализацию свойств класса значениями

Инициализировать все свойства класса нужно вручную (конструкторы этого не делают автоматически)

Конструктор клааса вызывается при инициализации объекта (val bob: Person = Person())

Конструктор есть в любом классе (неявный)

Существует три вида конструкторов: первичный, вторичный, неявный

Явный конструктор – конструктор, который определяет программист

Неявный конструктор – конструктор, который программист не определил в коде, он создался автоматически

Порядок вызова:

Сначала вызывается инициализатор (если определён), потом первичный конструктор, потом вторичный конструктор (если определён)
#### Первичный конструктор
Первичный конструктор – конструктор, который определяется в заголовке класса; первичный конструктор не выполняет никаких действий, он может только принимать данные из вне через параметры

Первичный конструктор определяется в заголовке класса с помощью ключевого слова constructor

Ллибо без ключевого слова с использованием круглых скобок ()

Первичный конструктор можно не объявлять вообще и тогда будет использоваться неявный конструктор

Параметры для первичного конструктора можно вообще не определять

Синтаксис объявления первичного конструктора:

|class ИмяКласса(параметры) или class ИмяКласса constructor(параметры) { // тело класса }|
| :- |

Примеры объявления первичного конструктора (все способы объявления): 

|// первичный конструктор и создание локальной переменной<br>class PersonA(a: Int) { val a: Int = a }<br>// первичный конструктор и создание свойства класса<br>class PersonB(val a: Int) {}<br>// первичный конструктор с ключевым словом и определённой локальной переменной<br>class PersonD constructor(a: Int) { val a: Int = a }<br>// первичный конструктор с ключевым словом и определённым свойством класса<br>class PersonC constructor(val a: Int) {}|
| :- |

#### Вторичный конструктор
Вторичный конструктор – конструктор, который определяется в теле класса; внутри вторичного конструктора можно делать что угодно, он также может принимать данные из вне через параметры, он должен отличаться по параметрам от первичного

Вторичный конструктор определяется в теле класса с помощью ключевого слова constructor

Вторичный конструктор можно не объявлять вообще и тогда будет использоваться первичный или неявный конструктор

Вторичных конструкторов можно создавать сколько угодно, но все они должны отличаться по количеству и/или типу параметров

Вторичные конструкторы всегда должны вызывать первичный конструктор, если первичный конструктор определён

Синтаксис объявления вторичного конструктора:

|constructor(параметры\_для\_первичного\_конструктора, дополнительные\_параметры): this(параметры\_для\_первичного\_конструктора) { // тело вторичного конструктора }|
| :- |

Примеры объявления вторичного конструктора:

|fun main() {<br>`    `val bob: PersonD = PersonD(1, 2, 3, 4)<br>}<br>class Person {<br>`    `constructor() {<br>`        `*println*("hello")<br>`    `}<br>}<br>// нет первичного, есть вторичный<br>class PersonA {<br>`    `constructor(a: Int) {<br>`        `*println*(a)<br>`    `}<br>}<br>// есть первичный без параметров, есть вторичный<br>class PersonB() {<br>`    `constructor(a: Int): this() {<br>`        `*println*(a)<br>`    `}<br>}<br>// есть первичный с параметрами, есть вторичный<br>class PersonC(a: Int) {<br>`    `constructor(b: Int, c: Int): this(b) {<br>`        `*println*("$b: $c")<br>`    `}<br>}<br>// про то, куда я могу передать параметры из вторичного конструктора<br>class PersonD(a: Int) {<br>`    `constructor(b: Int, c: Int): this(b) {<br>`        `*println*("$b: $c")<br>`    `}<br>`    `constructor(d: Int, e: Int, f: Int): this(d) { // могу передать первичному<br>`        `*println*("$d $e $f")<br>`    `}<br>`    `constructor(g: Int, h: Int, i: Int, j: Int): this(g, h, i) { // могу передать вторичному<br>`        `*println*("$g $h $i $j")<br>`    `}<br>}|
| :- |

Вопросы:

Можно ли обратиться к конструктору внутри метода? - нет

Можно ли вызывать другие конструкторы в теле конструкторов? - нет

Если переменную объявить во вторичном конструкторе, то она будет доступна по всему классу? – нет, только во вторичном

Что будет, если объявить в теле класса конструктор, даже когда первичный не был объявлен? 

В таком случае, в теле класса всё равно будет вторичный конструктор, а первичный будет объявлен неявно

В каких случаях нужно использовать ключевое слово constructor для определения первичного конструктора?

Если первичный конструктор не имеет никаких аннотаций или модификаторов доступа, то ключевое слово constructor можно опустить

#### Инициализаторы
Инициализатор – место, где мы инициализируем полученные через конструктор данные

Инициализатор вызывается раньше конструкторов

Внутри инициализаторов можно делать что угодно

Инициализаторов можно создавать сколько угодно

Синтаксис объявления инициализатора:

|init{ // тело }|
| :- |

Пример объявления инициализатора:

|fun main() {<br>`    `val mc: MyClass = MyClass()<br>}<br><br>class MyClass {<br>`    `init{<br>`        `*println*("in init")<br>`    `}<br>}|
| :- |

Пример создания нескольких инициализаторов:

|fun main() {<br>`    `val tom = Person("Tom", "Jerry")<br>`    `*println*(tom.namePerson)<br>`    `*println*(tom.surNamePerson)<br>}<br>class Person(name: String, surname: String) {<br>`    `val namePerson: String<br>`    `val surNamePerson: String<br>`    `init{<br>`        `namePerson = name<br>`    `}<br>`    `init{<br>`        `surNamePerson = surname<br>`    `}<br>}|
| :- |

Вопросы:

Можно ли в инициализаторе вызывать конструкторы класса? - нет

Можно ли вызывать методы класса в конструкторе или инциализаторе ? - да

Каким образом можно вызывать методы класса в конструкторе или инициализаторе (напрямую или через объект)? – напрямую

Если переменную объявить в инициализаторе, то она будет доступна по всему классу? – нет, только внутри init

#### Без конструкторов и инициализаторов
Класс можно создать без конструкторов, только с инициализатором:

|fun main() {<br>`    `val mc: Person = Person()<br>`    `*println*(mc.namePerson)<br>}<br><br>class Person {<br>`    `val namePerson: String<br>`    `init{<br>`        `namePerson = "Tom"<br>`    `}<br>}|
| :- |

Класс можно создать без инициализатора, только с конструктором:

|fun main() {<br>`    `val mc: Person = Person("Tom")<br>`    `*println*(mc.namePerson)<br>}<br><br>class Person(name: String) {<br>`    `val namePerson: String = name<br>}|
| :- |

Класс можно создать без конструкторов и инициализаторов:

|fun main() {<br>`    `val mc: Person = Person()<br>`    `*println*(mc.namePerson)<br>}<br><br>class Person {<br>`    `val namePerson: String = "Tom"<br>}|
| :- |

#### Взаимодействие конструкторов друг с другом
Вторичный конструктор всегда должен вызывать либо первичный, либо вторичный конструктор

Даже если первичный конструктор не принимает никаких параметров, вторичный конструктор всё равно должен его вызывать

Если первичный конструктор не был объявлен, то во вторичном конструкторе его не нужно вызывать

Если определён первичный конструктор и он принимает параметры, то вторичные конструкторы всегда должны передавать параметры либо первичному, либо вторичному конструктору (передавать параметры по кругу нельзя)

Если определён первичный конструктор и он принимает параметры - то вторичный конструктор всегда должен принимать параметры для первичного конструктора и передавать нужные параметры первичному конструктору:

|fun main() {<br>`    `val mc: Person = Person("Name", "Surname")<br>`    `*println*("${mc.namePerson} ${mc.surnamePerson}")<br>}<br><br>class Person(name: String) {<br>`    `val namePerson: String = name<br>`    `var surnamePerson: String = "none"<br><br>`    `constructor(name: String, surname: String): this(name) {<br>`        `surnamePerson = surname<br>`    `}<br>}|
| :- |

Если определён первичный конструктор и он принимает параметры, и определено больше одного вторичного конструктора - то все вторичные конструкторы всегда должны принимать параметры для первичного конструктора и передавать нужные параметры первичному конструктору:

|fun main() {<br>`    `val mc: Person = Person("Name", "Surname", 22)<br>`    `*println*("${mc.namePerson} ${mc.surnamePerson} ${mc.agePerson}")<br>}<br><br>class Person(name: String) {<br>`    `val namePerson: String = name<br>`    `var surnamePerson: String = "none"<br>`    `var agePerson: Int = 0<br><br>`    `constructor(name: String, surname: String): this(name) {<br>`        `surnamePerson = surname<br>`    `}<br>`    `constructor(name: String, surname: String, age: Int): this(name) {<br>`        `surnamePerson = surname<br>`        `agePerson = age<br>`    `}<br>}|
| :- |

Если определён первичный конструктор и он принимает параметры, и определено больше одного вторичного конструктора - то один из вторичных конструкторов всегда должен принимать параметры для вторичного конструктора и передавать нужные параметры первичному конструктору, а другие должны вызывать этот вторичный конструктор, либо вызывать другой вторичный конструктор:

|fun main() {<br>`    `val mc: Person = Person("Name", "Surname", 22)<br>`    `*println*("${mc.namePerson} ${mc.surnamePerson} ${mc.agePerson}")<br>}<br><br>class Person(name: String) {<br>`    `val namePerson: String = name<br>`    `var surnamePerson: String = "none"<br>`    `var agePerson: Int = 0<br><br>`    `constructor(name: String, surname: String): this(name) {<br>`        `surnamePerson = surname<br>`    `}<br>`    `constructor(name: String, surname: String, age: Int): this(name, surname) {<br>`        `agePerson = age<br>`    `}<br>}|
| :- |

Если не объявлен первичный конструктор, то во вторичном конструкторе не нужно ссылаться на неявный конструктор (иначе возникнет ошибка):

|fun main() {<br>`    `val mc: Person = Person("Name")<br>`    `*println*("${mc.namePerson}")<br>}<br><br>class Person {<br>`    `var namePerson: String = "none"<br><br>`    `constructor(name: String) {<br>`        `namePerson = name<br>`    `}<br>}|
| :- |

Даже если первичный конструктор не принимает никаких параметров, вторичный конструктор всё равно должен его вызывать (иначе возникнет ошибка):

|fun main() {<br>`    `val mc: Person = Person("Name")<br>`    `*println*("${mc.namePerson}")<br>}<br><br>class Person() {<br>`    `var namePerson: String = "none"<br><br>`    `constructor(name: String): this() {<br>`        `namePerson = name<br>`    `}<br>}|
| :- |

Вопросы:

Доступны ли локальные переменные одного конструктора другому конструктору?
#### Взаимодействие конструкторов и инициализаторов
Инициализатор можно использовать как тело для первоначального конструктора:

|fun main() {<br>`    `val mc: Person = Person("Tom")<br>`    `*println*(mc.namePerson)<br>}<br><br>class Person(name: String) {<br>`    `val namePerson: String<br>`    `init{<br>`        `namePerson = name<br>`    `}<br>}|
| :- |

Вопросы:

С инициализатором может работать только первичный конструктор или любой? – только первичный

Переменные, объявленные внутри вторичных конструкторов доступны внутри инициализатора? – нет

Переменные принятые вторичным конструктором доступны внутри инициализатора? – нет
#### val, var параметры и конструкторы
Если не объявить val или var перед параметром в первичном конструкторе, то такой параметр становиться локальной переменной для конструктора; такую переменную можно потом присвоить свойству класса при объявлении этого свойства или использовать в инициализаторе (внутри методов, вторичных конструкторов эти локальные переменные использовать нельзя):

|fun main() {<br>`    `val obPerson = Person("Tom")<br>`    `val obCar = Car("BMW")<br>`    `*println*("${obPerson.namePerson} ${obCar.nameCar}")<br>}<br>// можно использовать либо здесь<br>class Person(name: String) {<br>`    `var namePerson: String = name<br>}<br>// либо здесь<br>class Car(name: String) {<br>`    `var nameCar: String = "none"<br>`    `init {<br>`        `nameCar = name<br>`    `}<br>}|
| :- |

Если объявить val или var перед параметром в первичном конструкторе, то такой параметр становится свойством класса

|fun main() {<br>`    `val obPerson = Person("Tom")<br>`    `*println*("${obPerson.name}")<br>}<br>class Person(val name: String) {<br>`    `// var namePerson: String = name<br>}|
| :- |

Во вторичных конструкторах нельзя объявлять val или var параметры

Во вторичных конструкторах они всегда неявно определены как val и являются локальными переменными вторичного конструктора

### \* Ключевое слово this
Можно использовать this как ссылку на член класса (свойство класса или метод)

||
| :- |

Можно использовать this как ссылку на другой конструктор в этом же классе:

В таком контексте this можно использовать только в заголовке вторичного конструктора

||
| :- |


Можно использовать this как ссылку на объект (чтобы передать этот объект методу или чтобы возвратить этот объект из метода, или присвоить объект переменной)

||
| :- |

### Ключевое слово return
return (в методах) – возвращает значение из метода и завершает его работу

return (в конструкторах) – просто завершает работу конструктора

return (в init) - нельзя использовать

Если метод возвращает результат, то необязательно этот результат куда-то присваивать
### Примеры


Как обратиться к членам класса (можно через объект, а можно напрямую через имя класса)?
## Абстрактные классы
### Об абстрактных классах (abstract class)
Абстрактный класс – класс, который объявляется с помощью ключевого слово abstract

Нельзя создать из абстрактного класса объект (абстрактный класс можно только наследовать)

Если класс наследует абстрактный класс, то он должен реализовать все его абстрактные члены, либо также стать абстрактным

open необязательно указывать, чтобы сделать абстрактный класс доступным к наследованию (абстрактный класс по умолчанию open)

Какие члены может содержать абстрактный класс:

Может содержать обычные свойства, методы, конструкторы, инициализаторы

Может содержать абстрактные свойства, абстрактные методы, конструкторы и инициализаторы не могут быть абстрактными

Во всех абстрактных классах определён неявный конструктор

Синтаксис объявления абстрактного класса:

|abstract class ИмяАбстрактногоКласса { // тело }|
| :- |

Как объявить абстрактный класс (разные способы):

|abstract class MyAbstractClass0 // без конструктора, без тела<br>abstract class MyAbstractClass1 { } // без конструктора, с телом<br>abstract class MyAbstractClass2() { } // с конструктором, с телом<br>abstract class MyAbstractClass3(a: Int) { } // с конструктором, с параметрами, с телом<br>abstract class MyAbstractClass4(val a: Int) { } // с конструктором, с параметрами, с телом|
| :- |

Синтаксис наследования абстрактного класса:

|class ИмяКласса: ИмяАбстрактногоКласса() { // тело }|
| :- |

Как наследовать абстрактный класс (разные способы):

|abstract class MyAbstractClass0 // без конструктора, без тела<br>abstract class MyAbstractClass1 { } // без конструктора, с телом<br>abstract class MyAbstractClass2() { } // с конструктором, с телом<br>abstract class MyAbstractClass3(a: Int) { } // с конструктором, с параметрами, с телом<br>abstract class MyAbstractClass4(val a: Int) { } // с конструктором, с параметрами, с телом<br><br>class MyClass0: MyAbstractClass0() { }<br>class MyClass1: MyAbstractClass1() { }<br>class MyClass2: MyAbstractClass2() { }<br>class MyClass3(a: Int): MyAbstractClass3(a) { }<br>class MyClass4(a: Int): MyAbstractClass4(a) { }|
| :- |

### Об абстрактных свойствах
Как объявить абстрактное свойство:

|fun main() {<br><br>}<br><br>abstract class MyAbstractClass {<br>`    `abstract var a: Int<br>}|
| :- |

### Об абстрактных методах
Как создать абстрактный метод:

|fun main() {<br><br>}<br><br>abstract class MyAbstractClass {<br>`    `abstract fun meth()<br>}|
| :- |

### О перегрузке абстрактных методов
Как перегрузить абстрактный метод:

|fun main() {<br><br>}<br><br>abstract class MyAbstractClass {<br>`    `abstract fun meth()<br>`    `abstract fun meth(a: Int)<br>}|
| :- |

### О абстрактных конструкторах
Нельзя создавать абстрактные конструкторы или инициализаторы
### Вопросы реализации абстрактных классов
Что если в абстрактном классе есть обычный метод и в подклассе есть метод с таким же именем?

Можно ли при наследовании абстрактного класса скрыть реализацию метода абстрактного класса в подклассе?

Можно ли создать обычный и абстрактный методы с одинаковыми именами?

|fun main() {<br><br>}<br><br>abstract class MyAbstractClass {<br>`    `abstract fun meth()<br>`    `fun meth(a: Int) {<br>`        `meth()<br>`    `}<br>}|
| :- |

Можно ли создать обычный и абстрактный методы с одинаковыми именами, но разными параметрами?

### \* Ключевое слово this
Всё также как и в классах

Вопросы:

Можно ли с помощью this ссылаться на абстрактные члены?
### \* Ключевое слово return
Всё также как и в классах
### \* Примеры
## Интерфейсы
### Об интерфейсах (interface)
Интерфейсы – классы, в которых его члены описаны лишь поверхностно

То есть описано, ЧТО должен делать, но НЕ описано КАК он должен это делать

Нельзя создать из интерфейса объект (интерфейс можно только наследовать)

Интерфейс и его члены имеют по умолчанию модификатор open

При реализации нужно реализовать все методы, поля, и по желанию те члены, которые реализованы по умолчанию

При реализации методов и полей перед ними нужно ставить override (обязательно, иначе возникнет ошибка)

Если класс реализует не все члены, то класс должен быть объявлен как абстрактный (или объявить вместо абстрактного класса интерфейс)

Класс одновременно может наследоваться от ОДНОГО класса и применять один или несколько интерфейсов

Какие члены может содержать интерфейс:

Может содержать обычные методы

Может содержать без реализации свойства, методы

Может содержать абстрактные свойства и методы (ключевое слово abstract можно использовать, но нет в нём никакой нужды)

Не может содержать свойства с реализацией, конструкторы, инициализаторы

Синтаксис объявления интерфейса:

|interface ИмяИнтерфейса { // тело }|
| :- |

Как объявить интерфейс (пример):

|interface Person {<br>`    `fun showHello()<br>}|
| :- |

Синтаксис наследования интерфейса:

|class ИмяКласса: ИмяИнтерфейса { // тело }|
| :- |

Как наследовать интерфейс:

|interface Person {<br>`    `fun showHello()<br>}<br><br>class Bob: Person {<br>`    `override fun showHello() {<br>`        `*println*("hello")<br>`    `}<br>}|
| :- |

Синтаксис наследования класса и интерфейса одновременно:

|class ИмяКласса: ИмяИнтерфейса, ИмяКласса() { // тело }|
| :- |

Как одновременно и наследовать класс и интерфейс:

|open class Car() {<br>`    `fun showCar() {<br>`        `*println*("hello")<br>`    `}<br>}<br><br>interface Person {<br>`    `fun showHello()<br>}<br><br>class Bob: Person, Car() {<br>`    `override fun showHello() {<br>`        `*println*("hello")<br>`        `showCar()<br>`    `}<br>}|
| :- |

Вопросы:

Обязательно ли писать имя интерфейса вначале? – необязательно, не важно в каком порядке будут наследованы интерфейсы и класс

Можно ли реализовать несколько интерфейсов одновременно? - да

Можно ли реализовать несколько интерфейсов и классов одновременно? – интерфейсов можно реализовать сколько угодно, класс можно наследовать только один

|open class Car() {<br>`    `fun showCar() {<br>`        `*println*("hello")<br>`    `}<br>}<br><br>interface Person {<br>`    `fun showHello()<br>}<br><br>interface Animal {<br>`    `fun showHello()<br>}<br><br>class Bob: Person, Car(), Animal {<br>`    `override fun showHello() {<br>`        `*println*("hello")<br>`        `showCar()<br>`    `}<br>}|
| :- |

### О свойствах интерфейса
Как объявить свойство интерфейса:

||
| :- |

Обычные свойства можно объявлять, но нельзя их инициализировать
### О методах интерфейса
Как объявить метод без реализации:

|interface MyInterface {<br>`    `fun myMethod() // можно не указывать параметры<br>`    `fun myAnotherMethod(a: Int) // или можно указать параметры<br>}|
| :- |

Обычные методы можно объявлять и можно их реализовать сразу в интерфейсе
### О перегрузке методов интерфейса
Как перегрузить метод интерфейса:

|fun main() {<br><br>}<br><br>interface MyInterface {<br>`    `fun myMeth()<br>`    `fun myMeth(a: int)<br>}|
| :- |

Обычные методы тоже можно перегружать
### О конструкторах интерфейса
Интерфейсы не могут содержать конструкторы и инициализаторы
### Вопросы реализации интерфейсов
Что, если класс наследует класс и интерфейс и в этом классе и интерфейсе есть методы и свойства с одинаковыми именами?

В таком случае нужно обязательно реализовать в подклассе этот метод (вызвать метод класса или интерфейса можно с помощью конструкции super<имя\_класса\_или\_интерфейса>.имя\_метода)

Добавить примеры из Java интерфейсов
### \* Ключевое слово this
### \* Ключевое слово return
### \* Примеры
## Data классы
### О data классах
Data классы – всё как и в обычных классах, кроме того, что

Первичный конструктор должен иметь как минимум один параметр

Все параметры в конструкторе должны быть объявлены с помощью ключевых слов val или var

Класс не должен определяться с модификаторами open, abstract, sealed, inner

И содержит методы уже с реализацией equals(), hashCode(), toString(), copy()

Какие члены может содержать:

Может содержать свойства, методы, конструкторы, инициализаторы

Содержит методы с реализацией equals(), hashCode(), toString(), copy()

Синтаксис объявления data класса:

|data class ИмяКласса(var имяПеременной) { // тело }|
| :- |

Как объявить data класс:

|fun main() {<br>`    `val bob = Person(21)<br>`    `*println*(bob.age)<br>}<br><br>data class Person(var age: Int)|
| :- |

### Примеры
Как использовать методы data классов (на примере toString()):

Свойства, которые определены не в первичном конструкторе не используются в методах toString(), equals(), hashCode()

|<p>fun main() {<br>`    `val bob = Person(21)<br>`    `*println*(bob.toString())<br>}<br><br>data class Person(var age: Int)</p><p></p><p># Вывод:</p><p># Person(age=21)</p>|
| :- |

Как переопределить методы data классов (на примере toString()):

|fun main() {<br>`    `val bob = Person(21)<br>`    `*println*(bob.toString())<br>}<br><br>data class Person(var age: Int) {<br>`    `override fun toString(): String {<br>`        `return age.toString()<br>`    `}<br>}|
| :- |

## Enum классы
### Об enum классах
Enum класс – всё как и в обычных классах, кроме того, что

Первее всего в теле классе нужно объявить константы

И содержит встроенные свойства (name и ordinal) и методы (valueOf(value: String) и values())

Какие члены может содержать:

Может содержать свойства, методы, конструкторы, инициализаторы

Может содержать константы (константы должны быть объявлены первее всего, иначе возникнет ошибка)

Синтаксис объявления enum класса:

|<p>enum class ИмяEnumКласса { </p><p>`    `константа1, константа2, константа3</p><p>`    `// тело </p><p>}</p>|
| :- |

Как объявить enum класс:

||
| :- |

Синтаксис создания объекта enum класса:

||
| :- |

Как создать объект enum класса:

||
| :- |

### Константы enum класса
Константы – это по сути объекты enum класса

Требования к именам констант такие же, как и требования к именам переменных

Константы определяются через запятую

Если после списка констант в enum класс добавить ещё какие-то члены, то в таком случае после списка констант должна стоять точка с запятой (иначе возникнет ошибка)

Если для одной константы определено тело, то и для всех остальных констант должны быть определены тела (иначе возникнет ошибка)

Члены определённые в enum классе являются членами для всех констант (определённые члены будут доступны к вызову через любую константу с помощью точечной нотации)

Как создать обычный список констант:

||
| :- |

Как создать обычный список констант (с использованием точки с запятой):

||
| :- |

Как создать обычный список констант (с использованием тел):

||
| :- |

Как создать обычный список констант (с конструктором без аргументов):

||
| :- |

Как создать обычный список констант (с конструктором с аргументами):

||
| :- |

Как создать обычный список констант (с методом):

||
| :- |

### Примеры
Убрать отсюда главу с примерами и добавить примеры в другие главы

Как создать перечисление (без конструктора):

|fun main() {<br>`    `var day: Week = Week.*MONDAY<br>`    `println*(day)<br>}<br><br>enum class Week {<br>`    `*MONDAY*, *TUESDAY*, *WEDNESDAY*, *THURSDAY*, *FRIDAY*, *SATURDAY*, *SUNDAY*<br>}|
| :- |

Как создать перечисление (с конструктором):

|fun main() {<br>`    `var day: Week = Week.*MONDAY<br>`    `println*(day)<br>`    `*println*(day.number)<br>}<br><br>enum class Week(val number: Int) {<br>`    `*MONDAY*(1), *TUESDAY*(2), *WEDNESDAY*(3),<br>`    `*THURSDAY*(4), *FRIDAY*(5), *SATURDAY*(6), *SUNDAY*(7)<br>}|
| :- |

Как создать перечисление (с конструктором и методом):

|fun main() {<br>`    `var day1: Week = Week.*MONDAY*<br>`    `var day2: Week = Week.*FRIDAY<br>`    `println*(day1.getDuration(day2))<br>}<br><br>enum class Week(val number: Int) {<br>`    `*MONDAY*(1), *TUESDAY*(2), *WEDNESDAY*(3),<br>`    `*THURSDAY*(4), *FRIDAY*(5), *SATURDAY*(6), *SUNDAY*(7);<br><br>`    `fun getDuration(day: Week): Int {<br>`        `return number - day.number<br>`    `}<br>}|
| :- |

Как использовать встроенные методы и поля:

|<p>fun main() {<br>`    `var day: Week = Week.*MONDAY<br>`    `println*(day.name)<br>`    `*println*(day.ordinal)<br>`    `*println*(Week.valueOf("MONDAY"))<br>`    `var arr = Week.values()<br>`    `for(i in arr) *println*(i)<br>}<br><br>enum class Week(val number: Int) {<br>`    `*MONDAY*(1), *TUESDAY*(2), *WEDNESDAY*(3),<br>`    `*THURSDAY*(4), *FRIDAY*(5), *SATURDAY*(6), *SUNDAY*(7);<br><br>`    `fun getDuration(day: Week): Int {<br>`        `return number - day.number<br>`    `}<br>}</p><p></p><p># Вывод:</p><p># MONDAY</p><p># 0</p><p># MONDAY</p><p># MONDAY</p><p># TUESDAY</p><p># WEDNESDAY</p><p># THURSDAY</p><p># FRIDAY</p><p># SATURDAY</p><p># SUNDAY</p>|
| :- |

Как определить в константе анонимный класс:

Константы перечислений могут определять анонимные классы, которые могут иметь собственные методы и свойства

Если для одной константы определено тело, то и для всех остальных констант должны быть определены тела (иначе возникнет ошибка)

|fun main() {<br>}<br><br>enum class DayTime {<br>`    `*DAY* {<br>`        `val stroka: String = "ya stroka"<br>`        `fun showHello() {<br>`            `*println*("hello $stroka")<br>`        `}<br>`    `};<br>}|
| :- |



Добавить к этому примеры использования, не убирать с этой главы

Перечисления содержат встроенные поля:

name – возвращает название константы в виде String

ordinal – возвращает порядковый номер константы)

Перечисления содержат встроенные методы:

valueOf(value: String) – возвращает объект перечисления по названию константы

values() – возвращает массив констант текущего перечисления
## Анонимные классы
### Об анонимных классах
Анонимный класс – это класс, но при его определении не используется ключевое слова class, класс не имеет имени

Анонимный класс может наследовать классы и интерфейсы

К членам анонимного класса можно обращаться через точечную нотацию

Анонимный объект можно передать в качестве аргумента или через return, или присвоить переменной

Какие члены может содержать анонимный объект:

Может содержать свойства, методы, инициализаторы

Не может содержать конструкторы

Синтаксис объявления анонимного объекта:

|object { // тело класса }|
| :- |

Как создать анонимный объект:

|fun main() {<br>`    `val bob = object {<br>`        `val name = "Bob"<br>`        `var age = 21<br>        <br>`        `fun sayHello() {<br>`            `*println*("hello")<br>`        `}<br>`    `}<br>}|
| :- |

### Примеры
Как создать анонимный объект (свойства, метод, инициализатор):

|<p>fun main() {<br>`    `val bob = object {<br>`        `val name = "Bob"<br>`        `var age = 21<br><br>`        `fun sayHello() {<br>`            `*println*("hello")<br>`        `}<br><br>`        `init {<br>`            `*println*("in init")<br>`        `}<br>`    `}<br><br>`    `*println*(bob.name)<br>`    `*println*(bob.age)<br>`    `bob.sayHello()<br>}</p><p></p><p>Вывод:</p><p>in init</p><p>Bob</p><p>21</p><p>hello</p>|
| :- |

Как создать анонимный класс и наследовать другой класс:

|fun main() {<br>`    `val bob = object: Person() {<br>`        `val name = "Bob"<br>`        `var age = 21<br><br>`        `fun showHello() {<br>`            `*println*("hello")<br>`        `}<br>`    `}<br>`    `bob.showHello()<br>`    `bob.showBye()<br>}<br><br>open class Person {<br>`    `fun showBye() {<br>`        `*println*("bye")<br>`    `}<br>}|
| :- |

## Анонимные классы компаньоны
### Об анонимных классах компаньонах
Анонимный класс компаньон – позволяет обращаться к методам и свойствам объекта через имя класса в котором находится анонимный класс компаньон (замена статическим членам класса Java); одновременное объявление класса и создание объекта

||
| :- |

Анонимный класс компаньон не имеет доступ ко всем членам класса, в котором находится:

||
| :- |

Анонимный класс компаньон может иметь имя:

||
| :- |


Зачем анонимному объекту и компаньону объекту имя?

В чём отличие между анонимным объектом и объектом компаньоном?
## Наследование
### Об наследовании
Наследование – механизм, обеспечивающий создание иерархических структур из классов
### Класс наследует класс
#### О наследовании классов
Что класс может наследовать вообще:

Класс может наследовать другой класс (только один), абстрактный класс (только один), интерфейс (безграничное количество)

Класс может наследовать только либо один класс, либо один абстрактный класс

Класс не может наследовать сам себя

Какие члены наследует класс от класса:

Наследует свойства, методы

Не наследует конструкторы, инициализаторы

Синтаксис наследования:

||
| :- |

Как наследовать класс:

||
| :- |



Подкласс может создавать свои новые члены, либо перезагружать унаследованные члены

Класс может наследовать только один другой класс (иначе возникнет ошибка)

Как наследовать класс:

Модификаторы наследования:

open – чтобы класс можно было наследовать

final – чтобы класс нельзя было наследовать (класс без open неявно определён как final)



Какие члены наследует подкласс:

Наследует свойства, методы

Не наследует конструкторы, инициализаторы









|Как наследовать класс|Способы|
| :- | :- |
|Без первичного конструктора|<p>Первый способ. В заголовке. </p><p>Нужно вызвать конструктор по умолчанию из подкласса</p><p>Сразу при объявлении наследования с помощью () после имени подкласса</p>|
||<p>Второй способ. В теле. </p><p>Нужно вызвать конструктор по умолчанию из подкласса</p><p>Нужно определить вторичный конструктор в подклассе</p><p>И в нём вызвать конструктор по умолчанию из суперкласса с помощью ключевого слова super()</p>|
|С первичным конструктором|<p>Первый способ. В заголовке.</p><p></p>|
||<p>Второй способ. В теле. </p><p>Нужно вызвать конструктор по умолчанию из подкласса</p><p>Нужно определить вторичный конструктор в подклассе</p><p>И в нём вызвать конструктор по умолчанию из суперкласса с помощью ключевого слова super()</p>|



Чтобы класс можно было унаследовать, нужно определить для этого класса аннотацию open

При наследовании подкласс должен вызывать первичный конструктор суперкласса или конструктор по умолчанию (если первичного конструктора нет в суперклассе)

Можно наследовать только один класс (множественное наследование недоступно)

Все классы по умолчанию наследуются от класса Any

Синтаксис наследования класса:

class имя\_подкласса: имя\_суперкласса() { // тело подкласса }

(первый способ, в заголовке):

open class Person {

`    `var name: String = "unknown"

}

class Bob: Person() {

}

(второй способ, в теле):

Пример:

open class Person {

`    `var name: String = "unknown"

}

class Bob: Person {

`    `constructor(): super() {

`    `}

}

Как наследовать класс с первичным конструктором (первый способ, в заголовке):

Если суперкласс имеет первичный или вторичный конструктор, то в заголовке подкласса нужно вызвать этот конструктор

Нужно вызвать конструктор суперкласса после названия класса через двоеточие

Пример:

open class Person(val name: String) {

`    `fun showName() {

`        `println(name)

`    `}

}

class Bob(nameBob: String): Person(nameBob) {

}

Как наследовать класс с первичным конструктором (второй способ, в теле):

Если суперкласс имеет первичный или вторичный конструктор, то в теле подкласса нужно вызвать этот конструктор

Нужно определить вторичный конструктор в подклассе и в нём вызвать конструктор из суперкласса с помощью ключевого слова super()

Пример:

open class Person(val name: String) {

`    `fun showName() {

`        `println(name)

`    `}

}

class Bob: Person {

`    `constructor(nameBob: String): super(nameBob) {



`    `}

}

Если в суперклассе определён только вторичный конструктор, то всё работает по такой же схеме

Если в подклассе определён первичный и вторичный конструкторы одновременно, то передача параметров конструктору суперкласса должна происходить через первичный конструктор

Если в подклассе определён только вторичный конструктор, то передачу парамтров конструктору суперкласса должна происходить через вторичный конструктор

Добавить примеры, когда в суперклассе определены первичный и несколько вторичных конструкторов

Добавить примеры, когда в суперклассе определены первичный и несколько вторичных конструкторов и в подклассе определены первичный и несколько вторичных конструкторов

Добавить примеры, когда в суперклассе определены только несколько вторичных конструкторов

Добавить примеры, когда в суперклассе определены только несколько вторичных конструкторов и в подклассе определены несколько вторичных конструкторов

Какие параметры может принимать первичный конструктор и вторичный конструктор (val и var)

Добавить примеры как создавать объекты и как создавать объекты на основе разных конструкторов
#### О переопределении свойств и методов класса 
Переопределение методов – это когда, к примеру, есть суперкласс и его подкласс, метод суперкласса переопределяется в подклассе, то есть заменяется новым методом, описанным в подклассе

Как переопределить свойство или метод:

open – чтобы разрешить переопределение члена класса (свойства класса или метода)

final – чтобы запретить переопределение члена класса (свойства класса или метода)

Пример:

||
| :- |






Функции, которые находятся в классе аналогичны методам в Java

Переопределить можно функцию, поле, геттер, сеттер

Чтобы член можно было переопределить нужно использовать ключевое слово open

Чтобы переопределить член в подклассе нужно использовать override

Как переопределить поле:

|open class Person {<br>`    `open var age: Int = 21<br>}<br><br>class Bob: Person() {<br>`    `override var age: Int = 31<br>}|
| :- |

Как переопределить метод:

|open class Person {<br>`    `open fun showHello() {<br>`        `*println*("hello")<br>`    `}<br>}<br><br>class Bob: Person() {<br>`    `override fun showHello() {<br>`        `*println*("hello Bob")<br>`    `}<br>}|
| :- |

Как переопределить геттер или сетер:

|open class Person {<br>`    `open var age: Int = 0<br>`        `set(value) {<br>`            `if(value < 100)<br>`                `**field** = value<br>`        `}<br>}<br>class Bob: Person() {<br>`    `override var age: Int = 0<br>`        `set(value) {<br>`            `if(value < 50)<br>`                `**field** = value<br>`        `}<br>}|
| :- |

Как запретить дальнейшее переопределение:

Сделать это можно с помощью ключевого слова final

|open class Person {<br>`    `open var age: Int = 0<br>`        `set(value) {<br>`            `if(value < 100)<br>`                `**field** = value<br>`        `}<br>}<br>open class Bob: Person() {<br>`    `final override var age: Int = 0<br>`        `set(value) {<br>`            `if(value < 50)<br>`                `**field** = value<br>`        `}<br>}<br><br>class Tom: Bob() {<br>`    `// переопределить уже не получится, возникнет ошибка<br>`    `// override var age: Int = 0<br>}|
| :- |









### Класс наследует абстрактный класс
### Класс наследует интерфейс
### Абстрактный класс наследует класс
Так можно делать
### Абстрактный класс наследует абстрактный класс
Так можно делать
### Абстрактный класс наследует интерфейс
Так можно делать
### Интерфейс наследует класс
### Интерфейс наследует абстрактный класс
### Интерфейс наследует интерфейс
### \* Наследование data классов
data классы нельзя наследовать

### \* Наследование enum классов
enum классы нельзя наследовать

### \* Наследование анонимных классов
Анонимные классы нельзя наследовать

### \* Полиморфизм
(что такое полиморфизм, как сделать полиморфизм)

### \* Ключевое слово super
Можно использовать super как ссылку на член из суперкласса:

Если в суперклассе уже есть поле или метод с определённым именем, то поле или метод с таким же именем в подклассе перекрывает поле или метод суперкласса

Чтобы использовать поле или метод суперкласса нужен следующий синтаксис: super.имя\_поля\_или\_метода

Пример:

||
| :- |

Можно использовать super как ссылку на конструктор из суперкласса:

При создании объекта подкласса используются оба конструктора: конструктор суперкласса – для создания родительской части, конструктор подкласса – для создания части подкласса

Можно ли использовать super() для вызова конструктора суперкласса в теле конструктора подкласса? – нет

Можно ли использовать super() для вызова конструктора суперкласса в теле метода подкласса? – нет

Нужно ли каждый раз из конструктора подкласса вызывать конструктор суперкласса? – да, абсолютно всегда

Какими способами можно вызвать конструктор суперкласса:

\* После объявления подкласса: class PersonB(): PersonA() {} – здесь PersonA() вызывает конструктор суперкласса

Если я вызываю этим способом, то необходимые параметры для суперконструктора должен принимать первичный конструктор подкласса (либо же можно передать литерал)

Если я в подклассе определил конструктор, то суперкласс тоже нужно определять с первичным конструктором

Через вторичный конструктор передать параметры таким способом не получится? – не получится

Таким способом можно вызывать первичный или вторичный конструктор суперкласса? – да

Как вызвать необходимый конструктор? – всё зависит от типа и количества параметров, которые будут переданы

\* С помощью ключевого слова super(): constructor(): super() – здесь super() вызывает конструктор суперкласса

Таким способом можно вызывать любой конструктор суперкласса, но только через вторичный констуктор в подклассе

Пример:

|fun main() {<br>`    `val bob1: BobD = BobD(1, 2, 3)<br>`    `val bob2: BobD = BobD(1, 2, 3, 4)<br>}<br><br>open class PersonA<br>open class PersonB(val a: Int)<br>open class PersonC(a: Int) {<br>`    `val a = a<br>}<br>open class PersonD(a: Int) {<br>`    `constructor(b: Int, c: Int): this(b) {<br>`        `*println*("$b $c")<br>`    `}<br>`    `constructor(d: Int, e: Int, f: Int): this(d) {<br>`        `*println*("$d $e $f")<br>`    `}<br>`    `constructor(g: Int, h: Int, i: Int, j: Int): this(g, h, i) {<br>`        `*println*("$g $h $i $j")<br>`    `}<br>}<br><br>class BobA(): PersonA() // первый способ<br>class BobB(val b: Int): PersonB(b) // первый способ<br>class BobC(val b: Int): PersonC(b) // первый способ<br>class BobD: PersonD {<br>`    `constructor(bb: Int, cc: Int, dd: Int): super(bb) { // второй способ<br>`        `*println*("$bb $cc $dd")<br>`    `}<br>`    `constructor(bb: Int, cc: Int, dd: Int, ff: Int): super(bb, cc) { // второй способ<br>`        `*println*("$bb $cc $dd $ff")<br>`    `}<br>}|
| :- |

Можно ли использовать super как ссылку на объект (чтобы передать этот объект методу, к примеру)? – нет

### Ключевое слово open
open (перед классом) – означает, что класс можно наследовать (класс без open неявно определён как final)

open (перед членом класса) – означает, что член можно переопределить

### Ключевое слово final
final (перед классом) – означает, что класс нельзя наследовать

final (перед членом класса) – означает, что член нельзя переопределить

### Примеры
При создании объекта подкласса сначала создаётся объект суперкласса:

|fun main() {<br>`    `val ob = Tom()<br>`    `ob.sayBob()<br>`    `ob.sayTom()<br>}<br><br>open class Bob {<br>`    `fun sayBob() {<br>`        `*println*("Bob")<br>`    `}<br><br>`    `constructor() {<br>`        `*println*("in Bobs constructor")<br>`    `}<br>}<br><br>class Tom: Bob() {<br>`    `fun sayTom() {<br>`        `*println*("Tom")<br>`    `}<br>}|
| :- |

Если хотябы один из конструкторов суперкласса принимает параметры, то из подкласса нужно обращаться к одному из этих конструкторов:

|fun main() {<br>`    `val ob = Tom()<br>`    `ob.sayBob()<br>`    `ob.sayTom()<br>}<br><br>open class Bob() {<br>`    `fun sayBob() {<br>`        `*println*("Bob")<br>`    `}<br><br>`    `constructor(surname: String): this() {<br>`        `*println*("in Bobs constructor")<br>`    `}<br>}<br><br>class Tom: Bob() {<br>`    `fun sayTom() {<br>`        `*println*("Tom")<br>`    `}<br>}|
| :- |

## Влаживание
### Вложенные классы
Классы вложенные в классы

Абстрактные классы вложенные в классы

И т.д.


Вложенные классы – классы, которые определены в других классах

Вложенные классы по умолчанию объявлены как public (можно объявлить как private)

Вложенные классы не имеют никакого доступа к членам внешнего класса

Внутренние классы – классы, которые определены в других класса с помощью ключевого слова inner

Внутренние классы по умолчанию объявлены как public (можно объявить как private)

Внутренние классы имют непосредственный доступ ко всем членам внешнего класса

Если внутренний класс имеем член с таким же именем, как и у внешнего класса, то по имени этого члена во внутреннем классе будет вызываться член именно внутреннего класса, а чтобы получить доступ к члену внешнего класса из внутреннего класса нужно использовать конструкцию this@имя\_внешнего\_класса.имя\_члена

Как создать вложенный класс:

|fun main() {<br>`    `// объект можно определить здесь<br>`    `var bob: Person.Account = Person.Account()<br>`    `bob.showUsername()<br>}<br><br>class Person() {<br>`    `fun showName() {<br>`        `*println*("name")<br>`        `// объект можно определить здесь<br>`        `var bob: Account = Account()<br>`        `bob.showUsername()<br>`    `}<br><br>`    `class Account() {<br>`        `fun showUsername() {<br>`            `*println*("username")<br>`        `}<br>`    `}<br>}|
| :- |

Как создать внутренний класс:

|fun main() {<br>`    `// объект можно определить здесь<br>`    `var tom: Person = Person()<br>`    `var bob: Person.Account = tom.Account()<br>`    `bob.showUsername()<br>}<br><br>class Person() {<br>`    `fun showName() {<br>`        `*println*("name")<br>`        `// объект можно определить здесь<br>`        `var bob: Account = Account()<br>`        `bob.showUsername()<br>`    `}<br><br>`    `inner class Account() {<br>`        `fun showUsername() {<br>`            `*println*("username")<br>`            `// имеет прямой доступ к членам внешнего класса<br>`            `showName()<br>`        `}<br>`    `}<br>}|
| :- |
















## Декомпозиция
Декомпозиция – распаковка свойств объекта

Как декомпозировать data класс:

||
| :- |

## Делегирование

## Пакеты и импорт
Пакет – группа логически связанных файлов (место на диске, куда складываются файлы .class)

Место куда будут сохранятся пакеты определяет программист вручную

Место откуда будут браться пакеты определяется через системную переменную CLASSPATH

Можно импортировать не все члены пакета, а отдельные его части (класс, функцию)

Как создать пакет (package):

package название\_пакета - добавляет текущий файл в пакет

|package email<br><br>fun showHello() {<br>`    `*println*("hello")<br>}|
| :- |

Как импортировать пакет (import):

import название\_пакета - добавляет пакет в текущий файл

|import email.\*<br><br>fun main() {<br>`    `*showHello*()<br>}|
| :- |

Как импортировать пакет и назначить ему всевдоним (as):

import название\_пакета as псевдоним - добавляет пакет в текущий файл под указанным псевдонимом

|import email.showHello as hello<br><br>fun main() {<br>`    `*hello*()<br>}|
| :- |

Kotlin имеет ряд встроенных пакетов, которые подключаются по умолчанию в любой файл на языке Kotlin:

kotlin.\*, kotlin.annotation.\*, kotlin.collections.\*, kotlin.comparisons.\*, kotlin.io.\*, kotlin.ranges.\*, kotlin.sequences.\*, kotlin.text.\*

Эти пакеты не нужно вручную импортировать, они уже импортированы
## Вопросы
### Модификаторы видимости по умолчанию
### Модификаторы наследования по умолчанию
### Области действия и ООП
Весь список модификаторов




Модификаторы доступа по умолчанию

private

protected

internal

public








Какие бывают модификаторы

Какие типы поддерживают какие модификаторы

Модификаторы по умолчанию для разных типов

private, protected, internal, public

Найти об этом информацию в интернете

Для классов, для абстрактных классов, для интерфейсов, для data классов, для enum классов

Для их членов

Модификаторы для классов

Модификаторы для абстрактных классов
### Ключевые слова и ООП
### val, var и ООП
#### val, var и классы, объекты, методы, конструкторы
#### val, var и абстрактные классы
#### val, var и интерфейсы
# Обобщённое программирование
## Обобщённые классы и функции
Обобщеннные классы – позволяют определять шаблоны, в которые можно подставлять различные типы

Как создать обобщение:

|fun main() {<br>`    `val bob: Person<Int> = Person(21)<br>`    `bob.showSometing()<br>`    `val tom: Person<String> = Person("hello")<br>}<br><br>class Person<T>(val something: T) {<br>`    `fun showSometing() {<br>`        `*println*(something)<br>`    `}<br>}|
| :- |

Как создать несколько обобщений:

|fun main() {<br>`    `val bob: Person<Int, String> = Person(21, "text")<br>`    `bob.showSometing()<br>`    `val tom: Person<String, Double> = Person("hello", 21.5)<br>}<br><br>class Person<T, V>(val something: T, val more: V) {<br>`    `fun showSometing() {<br>`        `*println*(something)<br>`    `}<br>`    `fun showMore() {<br>`        `*println*(more)<br>`    `}<br>}|
| :- |

Как создать обобщённые функции:

Обобщеннные фукнции – позволяют определять шаблоны, в которые можно подставлять различные типы

Можно создавать несколько обобщений

|fun main() {<br>`    `fun <T> showSometing(something: T) {<br>`        `*println*(something)<br>`    `}<br><br>`    `showSometing("hello")<br>`    `showSometing(21)<br>}|
| :- |

Как ограничить обобщение:

Ограничить обобщение – определить для него класс или интерфейс (только тот класс или интерфейс, который наследуют или реализуют этот тип могут быть приняты в качестве типа в обобщённом типе)

|fun main() {<br>`    `*whatBigger*(21, 100)<br>}<br><br>fun <T: Comparable<T>> whatBigger(a: T, b: T) {<br>`    `if(a > b) *println*(a)<br>`    `else *println*(b)<br>}|
| :- |

Как установить несколько ограничений:

Если для параметра нужно установить несколько ограничений, то все они указываются после возвращаемого типа функции, после слова where, через запятую

|fun main() {<br>`    `*whatBigger*(21, 100)<br>}<br><br>fun <T> whatBigger(a: T, b: T) where T:Comparable<T>, T:Number {<br>`    `if(a > b) *println*(a)<br>`    `else *println*(b)<br>}|
| :- |

Таким же образом накладываются ограничения и на классы
## Вариантность, ковариантность, контрвариантность
По умолчанию все обобщённые типы инвариантны

Инвариантность – это когда тип T может быть только этого типа (суперклассы и подклассы типа T нельзя применять)

Ковариантность – позволяет переменным класса с типом T присвоить объект класса T, где в качестве T могут быть подклассы класса T

Ковариантность – позволяет переменным присваивать объекты их обобщённых типов и типов ниже по иерархии (подклассы)

В каком случае допустима ковариантность:

Если объект нашего класса только представляет значения (не изменяет их), то мы можем допустить, что в нём хранится значение ниже по иерархии обобщённого типа (тип T и его наследники)

Как объяснить компилятору, что обобщённый класс ковариантен:

Ключевое слово out (то есть как бы говорим, что класс будет только показывать значения этого типа и не будет их изменять)

В конструкторе должны быть поля только val (неизменяемые), если будет var – возникнет ошибка

Теперь можно делать так:

|package myPacket<br><br>fun main() {<br>`    `val myOb1: MyClass<Int> = MyClass<Int>(5)<br>`    `val myOb2: MyClass<Number> = myOb1<br>`    `// ковариантность позволяет переменным класса с типом T<br>`    `// присвоить объект класса T, где в качестве T могут быть подклассы класса T<br>`    `// myOb1 = MyClass<Double>(10.0) // так делать нельзя, возникнет ошибка<br>`    `// myOb2.value = 10 // так делать нельзя, возникнет ошибка<br>`    `myOb2.showValue()<br>}<br><br>class MyClass<out T>(val value: T){<br>`    `fun showValue() {<br>`        `*println*("value = $value")<br>`    `}<br>}|
| :- |
Как объяснить компилятору ковариантность на месте использования (когда нам не нужно, чтобы весь класс был ковариантным):

Можно поставить в качестве параметра или возвращаемого аргумента ковариантное обобщение (только это ковариантность на месте использования и значит)

Контрвариантность:

Контрвариантность – как ковариантность, только мы устанавливаем нижнюю границу

Используем ключевое слово in

Можем применять как на уровне объявления, так и на уровне использования

# Дополнительные возможности ООП
## Обработка исключений
## Значение null, тип Nullable (?, ?:, ?., !!)
null – литерал, который указывает, что переменная не имеет значения

Nullable – тип, которому мы можем присвоить значение null (базовому типу данных null присвоить нельзя)

Как превратить обычный тип в тип Nullable (нужно поставить после названия типа вопросительный знак):

|<p>val a: Int = null // так нельзя делать, возникнет ошибка</p><p>val b: Int? = null // так нормально</p>|
| :- |


У объектов типа Nullable нельзя вызывать напрямую те же функции и свойства, что и у обычных типов (можно через ?.):

|fun main() {<br>`    `var message: String? = "hello"<br>`    `*println*(message.length) // так делать нельзя<br>}|
| :- |


Нельзя передавать значения типа Nullable в качестве арумента в функцию, где требуется тип, который не может представлять тип Nullable:

|fun main() {<br>`    `var message: String? = "hello"<br>`    `*hello*(message) // так делать нельзя<br>}<br><br>fun hello(a: String) { // тип String не представляет тип Nullable (String?)<br>`    `*println*(a)<br>}|
| :- |

Оператор ?:

?: – оператор "элвис" – возвращает значение слева если значение != null, иначе возвращает значение справа

|<p>fun main() {<br>`    `val name: String? = "name"<br>`    `val userName: String = name ?: "unknown"<br><br>`    `val age: Int? = null<br>`    `val userAge: Int = age ?: 0<br><br>`    `*println*(userName)<br>`    `*println*(userAge)<br>}</p><p></p><p>Вывод:</p><p>name</p><p>0</p>|
| :- |

Оператор ?.

?. – оператор безопасного вызова – обращается к члену объекта если значение != null, иначе возвращает значение null

|<p>fun main() {<br>`    `var name: String? = "name"<br>`    `var lengthName: Int? = name?.length<br><br>`    `var surname: String? = null<br>`    `var lengthSurname: Int? = surname?.length<br><br>`    `*println*(lengthName)<br>`    `*println*(lengthSurname)<br>}</p><p></p><p>Вывод:</p><p>4</p><p>null</p>|
| :- |

Оператор !!

!! – оператор "это не null" (not null assertion) – возвращает значение слева если значение != null, иначе выбрасывает исключение NullPointerException (выброс NPE должен быть обработан в try-catch иначе программа аварийно завершится)

|fun main() {<br>`    `try {<br>`        `val name : String?  = "name"<br>`        `val id: String = name!!<br>`        `*println*(id)<br>`    `} catch (e: Exception) {<br>`        `*println*(e.message)<br>`    `}<br>}|
| :- |

## Преобразование типа (as, as?)
Преобразование типа – это когда мы один тип преобразовываем в другой

Какие есть встроенные методы преобразования типов:

Эти методы есть у всех базовых типов (набор функций у каждого типа может отличаться)

toByte, toShort, toInt, toLong, toFloat, toDouble, toChar

Синтаксис использования оператора as или as?:

|значение as тип\_данных|
| :- |

Оператор as:

Преобразовывает значение в указанный тип данных (если преобразование невозмножно, то сгенерируется исключение)

|fun main() {<br>`    `val nameBob: String? = "name"<br>`    `val nameTom: String = nameBob as String<br>`    `*println*(nameTom)<br>}|
| :- |

Оператор as?:

Преобразовывает значение в Nullable тип данных (если преобразование невозмножно, то возвратится значение null)

|fun main() {<br>`    `val nameBob: String? = "name"<br>`    `val nameTom = nameBob as? String // nameTom преобразуется в String?<br>    <br>`    `*println*(nameTom)<br>}|
| :- |

Преобразовать ТИП ОБЪЕКТА в ДРУГОЙ ТИП можно только если тип объекта является наследником другого типа:

|<p>fun main() {<br>`    `val personBob = PersonBob("Bob")<br>`    `val personTom = personBob as? PersonTom // преобразование нельзя сделать, personTom == null<br>    <br>`    `val employee = Employee("name")<br>`    `val person = employee as? Person // преобразование успешно, person == Person<br>}</p><p><br>class PersonBob(val name: String)<br>class PersonTom(val name: String)<br><br>open class Person(val name: String)<br>class Employee(name: String): Person(name)</p>|
| :- |

## Принадлежность типа (is)
Проверка на принадлежность типа – проверить принадлежит ли значение к определённому типу данных

Оператор is:

is – проверяет выражение на принадлежность к определённому типу данных

Оператор возвращает true, если значение слева от оператора принадлежит типу справа

Или если тип значения слева от оператора является наследником типа справа

!is – проверяет выражение на непринадлежность к определённому типу данных

Оператор возвращает true, если значение слева от оператора не принадлежит типу справа

Или если тип значения слева от оператора не является наследником типа справа

С какими переменными можно использовать оператор is:

Локальные переменные: к val – да, к var – да

Свойства класса: к val – да, к var – нет

Глобальное свойство: 

Свойство с модификатором open: нет

Свойство у которого явно определён геттер: нет

Делегированные свойства: нет

Применяется к свойствам класса val (кроме свойств с модификатором open, или свойств для которых явным образом определён геттер)

Применяется к локальным переменным var, только если переменная не изменяет своего значения в промежутке между проверкой и использованием и не используется в лямбда выражении, которое изменяет её, а также не является локальным делегированным свойством

Синтаксис использования оператора is: 

|значение is тип\_данных|
| :- |

## Функция расширение
Функция расширение – позволяет добавить функционал к уже существующему типу

В функции расширении мы можем обращаться к любым общедоступным членам (кроме private и protected)

Функция расширение не переопределяет методы, которые уже есть в классе (если сигнатура функции совпадёт с методом в классе, то функция расширение будет просто игнорироваться)

Синтаксис определения функции расширения:

|fun тип.имя\_функции(параметры): возвращаемый\_тип { // тело }|
| :- |

Пример:

|fun main() {<br>`    `*println*(4.*square*())<br>`    `*println*("hello world".*wordCount*('l'))<br>}<br><br>fun Int.square(): Int { // определение функции расширения для Int<br>`    `return this \* this<br>}<br><br>fun String.wordCount(c: Char): Int { // определение функции расширения для String<br>`    `var count = 0<br>`    `for(n in this) {<br>`        `if(n == c) count++<br>`    `}<br>`    `return count<br>}|
| :- |

## Перегрузка оператора (operator)
Перегрузка оператора – изменение поведения для +, -, \* > и т.д., чтобы научить их как вести себя с разнообразными типами данных

Синтаксис перегрузки оператора:

|operator fun названиеОператора(параметрыЕслиНужны): возвращаемыйТип { // тело }|
| :- |

Перегрузка оператора + (plus(параметр)):

||
| :- |

Перегрузка оператора > (compareTo(параметр)):

||
| :- |

Перегрузка оператора +a (unaryPlus()):

||
| :- |

Перегрузка оператора для существующих типов (с помощью функции расширения):

||
| :- |

Какие операторы можно перегрузить:

## Делегированные свойства и делегаты(by)
### О делегированных свойствах и делегатах
Делегированные свойства – свойства, где геттером и/или сеттером управляет другой класс (делегат)

Делегат – класс, который управляет геттером и/или сеттером

Для каких переменных можно использовать делегат (для любых переменных):

Для глобальных свойств, для свойств класса, для локальных переменных

Встроенные делегаты:

lazy, observable, vetoable, notNull

Собственные делегаты:

Также можно создавать собственные делегаты

Синтаксис определения делегированного свойства:

|val\_или\_var имяСвойства: тип данных by делегат|
| :- |

### Собственные делегаты
Для val свойства делегат должен иметь только геттер

Для var свойства делегат должен иметь и геттер, и сеттер

Метод getValue():

thisRef – должен представлять тот же тип, что и свойство, к которому применяется делегат (или его родительский тип)

Хранит в себе ссылку на переменную, из которой будет возвращаться значение 

property – должен представлять тот же тип KProperty<\*> (или его родительский тип)

Хранит в себе property.name, которая хранит в себе имя переменной

Метод getValue() должен возвращать результат того же типа, что и тип свойства

Метод setValue():

Принимает три параметра:

thisRef – должен представлять тот же тип, что и свойство, к которому применяется делегат (или его родительский тип)

Хранит в себе ссылку на переменную, которой будет присваиваться значение

property – должен представлять тот же тип KProperty<\*> (или его родительский тип)

Хранит в себе property.name, которая хранит в себе имя переменной

value – должен представлять тот же тип, что и свойство, к которому применяется делегат (или его родительский тип)

Хранит в себе значение, которое мы указываем после знака =

Чтобы использовать переменные KProperty, нужно импортировать их пакет: import kotlin.reflect.KProperty

Как определить класс делегат и определить в нём методы getValue() и setValue():

Переменная valueName здесь объявлена только для того, чтобы хранить в себе значение переменной

(потому что переменная value недоступна в геттере и вместо value мы будем возвращать valueName)

|<p>import kotlin.reflect.KProperty<br><br>fun main() {<br>`    `val person = Person()<br>`    `person.name = "bob" // вызов setValue<br>`    `*println*(person.name) // вызов getValue<br>`    `person.name = "rick" // вызов setValue<br>`    `*println*(person.name) // вызов getValue<br>}<br><br>class Person {<br>`    `var name: String by Delegate("none")<br>}<br><br>class Delegate(var valueName: String) {<br>`    `operator fun getValue(thisRef: Any?, property: KProperty<\*>): String {<br>`        `return "in getValue ${thisRef}, ${property.name}, ${valueName}"<br>`    `}<br><br>`    `operator fun setValue(thisRef: Any?, property: KProperty<\*>, value: String) {<br>`        `valueName = value<br>`        `*println*("in setValue ${thisRef}, ${property.name}, ${valueName}")<br>`    `}<br>}</p><p></p><p>Вывод:</p><p>in setValue Person@7eda2dbb, name, bob</p><p>in getValue Person@7eda2dbb, name, bob</p><p>in setValue Person@7eda2dbb, name, rick</p><p>in getValue Person@7eda2dbb, name, rick</p>|
| :- |

### Встроенные делегаты
## Scope функции
Контекстная функция – встроен. функция, которая позволяет выполнить для некоторого объекта некоторый код в виде лямбда выражения

Контекстную функцию можно применять как функцию расширение, либо вызывать как отдельную фукнцию

apply и also возвращают объект контекста

let, run и with возвращают результат лямбды

this и it ничем не отличаются друг от друга по своей функциональности

let – функция расширение, принимает другую функцию:

it – объект, для которого вызывается функция

|fun main() {<br>`    `val person = Person("tom", "tom@gmail.com")<br>`    `person.name?.*let* **{** *println*(**it**) **}** // если не null, то показать переменную<br>}<br><br>class Person(val name: String?, var surname: String?)|
| :- |

with – функция расширение, которая принимает объект и другую функцию; обращаться к членам объекта можно напрямую:

|fun main() {<br>`    `val person = Person("tom", "tom@gmail.com")<br>`    `*println*(*with*(person) **{**<br>`        `if(email == null) "null@gmail.com"<br>`        `email<br>`    `**}**)<br>}<br><br>class Person(val name: String?, var email: String?)|
| :- |

run – функция расширение, которая принимает объект и другую функцию; обращаться к членам объекта можно напрямую:

|fun main() {<br>`    `val person = Person("tom", "tom@gmail.com")<br>`    `*println*(person.*run* **{**<br>`        `if(email == null) "null@gmail.com"<br>`        `email<br>`    `**}**)<br>}<br><br>class Person(val name: String?, var email: String?)|
| :- |

apply – функция расширение, которая принимает объект и другую функцию; обращаться к членам объекта можно напрямую:

this – объект, для которого вызывается фукнкция

В качестве результата возвращается объект, для которого была вызвана функция

|fun main() {<br>`    `val bob = Employee()<br>`    `bob.name("Bob")<br>`    `bob.age(26)<br>`    `bob.company("JetBrains")<br>`    `*println*("${bob.name}, ${bob.age}, ${bob.company}") // Bob (26) - JetBrains<br>}<br><br>data class Employee(var name: String = "", var age: Int = 0, var company: String = "") {<br>`    `fun age(\_age: Int): Employee = *apply* **{** age = \_age **}**<br>`    `fun name(\_name: String): Employee = *apply* **{** name = \_name **}**<br>`    `fun company(\_company: String): Employee = *apply* **{** company = \_company **}**<br>}|
| :- |

also – функция расширение, которая принимает объект и другую функцию; обращаться к членам объекта можно напрямую:

it – объект, для которого вызывается фукнкция

В качестве результата возвращается объект, для которого была вызвана функция

|fun main() {<br>`    `val person = Person("tom", null)<br>`    `person.*also* **{**<br>`        `if(**it**.email == null) {<br>`            `**it**.email = "null@gmail.com"<br>`            `*println*(**it**.email)<br>`        `}<br>`        `*println*(**it**.email)<br>`    `**}**<br>`    `*println*(person.email)<br>}<br><br>class Person(val name: String?, var email: String?)|
| :- |

## Инфиксная нотация

# Многопоточное программирование
Асинхронность – неодновременные процессы; запускает дополнительный процесс, который не блокирует основной процесс

Параллельность – одновременные процессы
## Корутины
Как добавить корутины в проект

Синхронность – это когда идёт один основной поток и он иногда запускает параллельные процессы

Параллельность – это когда работают сразу два или больше процессов

Как добавить корутины в проект: File – Project Structure – Libraries – + – From Maven – kotlinx-coroutines-core-jvm

### Корутины
Корутина – блок кода, который может выполниться параллельно с остальным кодом; корутины можно вызывать только в контексте корутины

### suspend
suspend – модификатор, который определяет функцию, которая может приостановить своё выполнение и возобновить его через некоторое время; suspend функции можно вызывать только из других функций или из корутин

|import kotlinx.coroutines.\*<br><br>suspend fun main() {<br>`    `for(i in 0..5) {<br>`        `*println*(i)<br>`        `delay(1000L)<br>`    `}<br>}|
| :- |

### coroutineScope
coroutineScope – функция, которая создаёт контекст корутины; может применяться только к suspend функциям

|<p>import kotlinx.coroutines.\*<br><br>suspend fun main()  = coroutineScope **{**<br>`    `*launch* **{**<br>`        `for(a in 0..5) {<br>`            `*println*(a)<br>`            `delay(1000L)<br>`        `}<br><br>`        `*println*("in end launch")<br>`    `**}**<br><br>`    `*println*("in end coroutineScope")<br>**}**</p><p></p><p>Вывод:</p><p>in end coroutineScope</p><p>0</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>in end launch</p>|
| :- |

### runBlocking
runBlocking – функция, которая создаёт контекст корутины; может применяться только к suspend функциям

|<p>import kotlinx.coroutines.\*<br><br>suspend fun main()  = *runBlocking* **{**<br>`    `*launch* **{**<br>`        `for(a in 0..5) {<br>`            `*println*(a)<br>`            `delay(1000L)<br>`        `}<br><br>`        `*println*("in end launch")<br>`    `**}**<br><br>`    `*println*("in end coroutineScope")<br>**}**</p><p></p><p>**Вывод:**</p><p>in end coroutineScope</p><p>0</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>in end launch</p>|
| :- |

### launch
launch – функция, которая создаёт корутину в виде блока кода и запускает её параллельно с основным кодом

Нужна когда не нужно возвращать результат из корутины и когда корутину нужно выполнить одновременно с другим кодом

launch озвращает объект Job

|<p>import kotlinx.coroutines.\*<br><br>suspend fun main()  = coroutineScope **{**<br>`    `*launch* **{**<br>`        `for(a in 0..5) {<br>`            `*println*(a)<br>`            `delay(1000L)<br>`        `}<br><br>`        `*println*("in end launch")<br>`    `**}**<br><br>`    `*println*("in end coroutineScope")<br>**}**</p><p></p><p>Вывод:</p><p>in end coroutineScope</p><p>0</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p>|
| :- |

### launch объект
launch возвращает объект Job

Объект Job содержит методы join() и start()

### launch объект, join()
Метод join() приостанавливает поток и ждёт пока корутина завершит свою работу

|<p>import kotlinx.coroutines.\*<br><br>suspend fun main()  = coroutineScope **{**<br>`    `val job = *launch* **{**<br>`        `for(a in 0..5) {<br>`            `*println*(a)<br>`            `delay(1000L)<br>`        `}<br>`        `*println*("in end launch")<br>`    `**}**<br><br>`    `*println*("in coroutineScope")<br>`    `job.join()<br>`    `*println*("in end coroutineScope")<br>**}**</p><p></p><p>**Вывод:**</p><p>in coroutineScope</p><p>0</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>in end launch</p><p>in end coroutineScope</p>|
| :- |

### launch(start = CoroutineStart.LAZY), start()
launch(start = CoroutineStart.LAZY) – позволяет только создать корутину, но не запустить

Метод start() позволяет запусить корутину

|<p>import kotlinx.coroutines.\*<br><br>suspend fun main()  = coroutineScope **{**<br>`    `val job = *launch*(start = CoroutineStart.*LAZY*) **{**<br>`        `for(a in 0..5) {<br>`            `*println*(a)<br>`            `delay(1000L)<br>`        `}<br>`        `*println*("in end launch")<br>`    `**}**<br><br>`    `*println*("in coroutineScope")<br>`    `job.start()<br>`    `*println*("in end coroutineScope")<br>**}**</p><p></p><p>**Вывод:**</p><p>in coroutineScope</p><p>in end coroutineScope</p><p>0</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>in end launch</p>|
| :- |


### async объект
async – функция, которая создаёт корутину в виде блока кода и запускает её параллельно с основным кодом 

Отличие async от launch в том, что она возвращает результат из корутины с помощью метода await()

async возвращает объект Deferred

Deferred наследуется от Job

|import kotlinx.coroutines.\*<br><br>suspend fun main()  = coroutineScope **{**<br>`    `val message = *async* **{**<br>`        `*println*("in start async")<br>`        `*returnHello*()<br>`    `**}**<br><br>`    `*println*("message: ${message.await()}")<br>`    `*println*("in end coroutineScope")<br>**}**<br><br>fun returnHello(): String {<br>`    `return "hello"<br>}|
| :- |

### Диспетчер корутины
Диспетчер корутины – определяет какой поток или какие потоки будут использоваться для выполнения корутины

Thread.currentThread() – возвращает данные потока корутины

Thread.currentThread().name – возвращает имя потока

|<p>import kotlinx.coroutines.\*<br><br>suspend fun main()  = coroutineScope **{**<br>`    `val job = *launch* **{**<br>`        `for(a in 0..5) {<br>`            `*println*(a)<br>`            `delay(1000L)<br>`        `}<br>`        `*println*("Thread.currentThread() ${Thread.currentThread()}")<br>`        `*println*("Thread.currentThread() ${Thread.currentThread().*name*}")<br>`        `*println*("in end launch")<br>`    `**}**<br><br>`    `*println*("in end coroutineScope")<br>**}**</p><p></p><p>**Вывод:**</p><p>in end coroutineScope</p><p>0</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>Thread.currentThread() Thread[DefaultDispatcher-worker-1,5,main]</p><p>Thread.currentThread() DefaultDispatcher-worker-1</p><p>in end launch</p>|
| :- |

Dispatchers.Default – применяется по умолчанию; подходит для интенсивных вычислений

Dispatchers.IO – подходит для операций ввода/вывода (операции с файлами, сетевые запросы)

Dispatchers.Main – применяется в графических приложениях Android или JavaFX

Dispatchers.Unconfined – применяется, когда не нужно фиксировать корутину в каком-то определённом потоке (не рекомендуется)

|<p>import kotlinx.coroutines.\*<br><br>suspend fun main()  = coroutineScope **{**<br>`    `val job = *launch*(Dispatchers.Default) **{**<br>`        `for(a in 0..5) {<br>`            `*println*(a)<br>`            `delay(1000L)<br>`        `}<br>`        `*println*("Thread.currentThread() ${Thread.currentThread()}")<br>`        `*println*("Thread.currentThread() ${Thread.currentThread().*name*}")<br>`        `*println*("in end launch")<br>`    `**}**<br><br>`    `*println*("in end coroutineScope")<br>**}**</p><p></p><p>**Вывод:**</p><p>in end coroutineScope</p><p>0</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>Thread.currentThread() Thread[DefaultDispatcher-worker-1,5,main]</p><p>Thread.currentThread() DefaultDispatcher-worker-1</p><p>in end launch</p>|
| :- |

newSingleThreadContext(имяПотока) – запускает корутину в потоке с определённым именем

|<p>import kotlinx.coroutines.\*<br><br>suspend fun main()  = coroutineScope **{**<br>`    `val job = *launch*(*newSingleThreadContext*("CustomName")) **{**<br>`        `for(a in 0..5) {<br>`            `*println*(a)<br>`            `delay(1000L)<br>`        `}<br>`        `*println*("Thread.currentThread() ${Thread.currentThread()}")<br>`        `*println*("Thread.currentThread() ${Thread.currentThread().*name*}")<br>`        `*println*("in end launch")<br>`    `**}**<br><br>`    `*println*("in end coroutineScope")<br>**}**</p><p></p><p>**Вывод:**</p><p>in end coroutineScope</p><p>0</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>Thread.currentThread() Thread[CustomName,5,main]</p><p>Thread.currentThread() CustomName</p><p>in end launch</p>|
| :- |

cancel() – метод объекта Job; останавливает работу корутины (применяется к launch, async)

cancelAndJoin() – метод объекта Job; останавливает работу корутины и ждёт её завершения (применяется к launch, async)

|import kotlinx.coroutines.\*<br><br>suspend fun main() = coroutineScope **{**<br>`    `val job = *launch* **{**<br>`        `for(a in 0..5) {<br>`            `*println*(a)<br>`            `delay(1000L)<br>`        `}<br>`        `*println*("in end launch")<br>`    `**}**<br>`    `*println*("in coroutineScope")<br>`    `*println*("wait 1 second")<br>`    `delay(1000L)<br>`    `job.cancel()<br>`    `*println*("in end coroutineScope")<br>**}**|
| :- |

### Каналы, send(element), receive()
Каналы – позволяют передавать данные между корутинами; каналы представлены интерфейсом Channel

send(element) – отправляет element в канал

receive() – получает element из канала (с методом receive() лучше всего использовать repeat() вместо for)

После работы с методом receive() всегда нужно закрывать канал с помощью метода close()

|<p>import kotlinx.coroutines.\*<br>import kotlinx.coroutines.channels.Channel<br><br>suspend fun main() = coroutineScope **{**<br>`    `val channel = *Channel*<Int>()<br>`    `val job = *launch* **{**<br>`        `for(a in 0..5) {<br>`            `channel.send(a)<br>`        `}<br>`        `*println*("in end launch")<br>`    `**}**<br>`    `*repeat*(6) **{**<br>`        `*println*(channel.receive())<br>`    `**}**<br>`    `channel.close()<br>`    `*println*("in end coroutineScope")<br>**}**</p><p></p><p>**Вывод:**</p><p>0</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>in end launch</p><p>in end coroutineScope</p>|
| :- |

## Асинхронные потоки
### Асинхронные потоки
Корутины возвращают одиночные значения, а асинхронные потоки возвращают набор объектов


# Коллекции и последовательности
В чём разница между ArrayList и MutableList?

## Об коллекциях в Kotlin
Коллекция – поставляемый с языком набор библиотек

В Kotlin нет собственных коллекций, он полагается на коллекции из Java

Все коллекции в Kotlin располагаются в пакете kotlin.collections

Какие бывают коллекции:

Неизменяемые коллекции (immutable), изменяемые коллекции (mutable)

## Неизменяемые коллекции
### Об неизменяемых коллекциях
Неизменяемые коллекции (immutable) – могут изменяться, в неё можно добавлять, в ней можно изменять, удалять элементы (в процессе подобных операций коллекция будет заново пересоздаваться)

На вершине находится интерфейс Iterable, который определяет функцию итератора для перебора коллекции

Затем идёт интерфейс Collection, который даёт возможность перебора элементов, проверки наличия элементов, чтения данных

Затем идёт интерфейс List, который представляет обычный список

И Set, который представляет неупорядоченную коллекцию элементов, не допускающую дублирования элементов

Отдельно стоит коллекция Map, которая представляет набор пар ключ-значение, где все ключи в коллекции являются уникальными

### Методы Collection
Это не все члены Collection, но основные:

size – возвращает количество эллементов в коллекции

isEmpty() – возвращает true, если коллекция пуста

contains(element) – возвращает true, если коллекция содержит element

containsAll(collection) – возвращает true, если коллекция содержит элементы коллекции collection
### Примеры

## Изменяемые коллекции
### Об изменяемых коллекциях
Изменяемые коллекции (mutable) – могут изменяться, в неё можно добавлять, в ней можно изменять, удалять элементы (в процессе подобных операций коллекция не будет заново пересоздаваться)

На вершине находится интерфейс MutableIterable, который определяет функцию итератора для перебора коллекции

Затем идёт интерфейс MutableCollection, который наследует интерфейс Collection

Затем идёт интерфейс MutableList, который представляет изменяемый список

И MutableSet, который представляет изменяемую неупорядоченную коллекцию элементов, не допускающую дублирования элементов

Отдельно стоит коллекция MuttableMap, которая представляет изменяемый набор пар ключ-значение, где все ключи в коллекции являются уникальными

### Методы MutableCollection
Это не все члены MutableCollection, но основные:

size – возвращает количество эллементов в коллекции

isEmpty() – возвращает true, если коллекция пуста

contains(element) – возвращает true, если коллекция содержит element

containsAll(collection) – возвращает true, если коллекция содержит элементы коллекции collection

add(element) – добавляет элемент

remove(element) – удаляет элемент

addAll(elements) – добавляет набор элеметнов

removeAll(elements) – удаляет набор элементов

clear() – удаляет все элементы из коллекции
### Примеры

## Методы Iterable
all(predicate: (T) -> Boolean): Boolean - возвращает true, если все элементы соответствуют предикату, который передается в функцию в качестве параметра

any(): Boolean – возвращает true, если коллекция содержит хотя бы один элемент

any(predicate: (T) -> Boolean): Boolean – Дополнительная версия; возвращает true, если хотя бы один элемент соответствуют предикату, который передается в функцию в качестве параметра

asSequence(): Sequence<T> – создает из коллекции последовательность

average(): Double – возвращает среднее значение для числовой коллекции типов Byte, Int, Short, Long, Float, Double

chunked(size: Int): List<List<T>> – расщепляет коллекцию на список, который состоит из объектов List, параметр size устанавливает максимальное количество элементов в каждом из списков

chunked(size: Int,transform: (List<T>) -> R): List<R> – Дополнительная версия; в качестве второго параметра получает функцию преобразования, которая преобразует каждый список в элемент новой коллекции

contains(element: T): Boolean – возвращает true, если коллекция содержит элемент element

count(): Int – возвращает количество элементов в коллекции

count(predicate: (T) -> Boolean): Int – Дополнительная версия; возвращает количество элементов, которые соответствуют предикату

distinct(): List<T> – возвращает новую коллекцию, которая содержит только уникальные элементы

distinctBy(selector: (T) -> K): List<T> – возвращает новую коллекцию, которая содержит только уникальные элементы с учетом функции селектора, которая передается в качестве параметра

drop(n: Int): List<T> – возвращает новую коллекцию, которая содержит все элементы за исключением первых n элементов

dropWhile(predicate: (T) -> Boolean): List<T> – возвращает новую коллекцию, которая содержит все элементы за исключением первых элементов, которые соответствуют предикату

elementAt(index: Int): T – возвращает элемент по индексу index. Если индекс выходит за пределы коллекции, то генерируется исключение типа IndexOutOfBoundsException

elementAtOrElse(index: Int, defaultValue: (Int) -> T): T – возвращает элемент по индексу index. Если индекс выходит за пределы коллекции, то возвращается значение, устанавливаемое функцией из параметра defaultValue

elementAtOrNull(index: Int): T? – возвращает элемент по индексу index. Если индекс выходит за пределы коллекции, то возвращается null

filter(predicate: (T) -> Boolean): List<T> – возвращает новую коллекцию из элементов, которые соответствуют предикату

filterNot(predicate: (T) -> Boolean): List<T> – возвращает новую коллекцию из элементов, которые НЕ соответствуют предикату

filterNotNull(): List<T> – возвращает новую коллекцию из элементов, которые не равны null

find(predicate: (T) -> Boolean): T? – возвращает первый элемент, который соответствует предикату. Если элемент не найден, то возвращается null

findLast(predicate: (T) -> Boolean): T? – возвращает последний элемент, который соответствует предикату. Если элемент не найден, то возвращается null

first(): T – возвращает первый элемент коллекции

first(predicate: (T) -> Boolean): T – Дополнительная версия возвращает; первый элемент, которые соответствует предикату; Если элемент не найден, то генерируется исключение типа NoSuchElementException

firstOrNull(): T? – возвращает первый элемент коллекции

firstOrNull(predicate: (T) -> Boolean): T? – Дополнительная версия; возвращает первый элемент, которые соответствует предикату; Если элемент не найден, то возвращается null

flatMap(transform: (T) -> List<R>): List<R> – преобразует коллекцию элементов типа T в коллекцию элементов типа R, используя функцию преобразования, которая передается в качестве параметра

fold(initial: R, operation: (acc: R, T) -> R): R – Возвращает значение, которое является результатом действия функции operation над каждым элементом коллекции. Первый параметр функции operation - результат работы функции над предыдущим элементом коллекции (при первом вызове - значение из параметра initial), в второй параметр - текущий элемент коллекции.

forEach(action: (T) -> Unit) – Выполняет для каждого элемента коллекции действие action.

groupBy(keySelector: (T) -> K): Map<K, List<T>> – Группирует элементы по ключу, который возвращается функцией keySelector. Результат функции карта Map, где ключ - собственно ключ элементов, а значение - список List из элементов, которые соответствуют этому ключу

groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> – Дополнительная версия; принимает функцию преобразования элементов

indexOf(element: T): Int – Возвращает индекс первого вхождения элемента element. Если элемент не найден, возвращается -1

indexOfFirst(predicate: (T) -> Boolean): Int – Возвращает индекс первого элемента, который соответствует предикату. Если элемент не найден, возвращается -1

indexOfLast(predicate: (T) -> Boolean): Int – Возвращает индекс последнего элемента, который соответствует предикату. Если элемент не найден, возвращается -1

intersect(other: Iterable): Set – Возвращает все элементы текущей коллекции, которые есть в коллекции other

joinToString(): String – Генерирует из коллекции строку

last(): T – возвращает последний элемент коллекции

last(predicate: (T) -> Boolean): T – Дополнительная версия; возвращает последний элемент, которые соответствует предикату; Если элемент не найден, то генерируется исключение типа NoSuchElementException

lastOrNull(): T? – возвращает последний элемент коллекции

lastOrNull(predicate: (T) -> Boolean): T? – Дополнительная версия; возвращает последний элемент, которые соответствует предикату; Если элемент не найден, то возвращается null

lastIndexOf(element: T): Int – Возвращает последний индекс элемента element. Если элемент не найден, возвращается -1

map(transform: (T) -> R): List<R> – Применяет к элементам коллекции функцию трансформации и возвращает новую коллекцию из новых элементов

mapIndexed(transform: (index: Int, T) -> R): List<R> – Применяет к элементам коллекции и их индексам функцию трансформации и возвращает новую коллекцию из новых элементов

mapNotNull(transform: (T) -> R?): List<R> – Применяет к элементам коллекции функцию трансформации и возвращает новую коллекцию из новых элементов, которые не равны null

maxOf(selector: (T) -> Double): Double – Возвращает максимальное значение на основе селектора

maxOfOrNull(selector: (T) -> Double): Double? – Возвращает максимальное значение на основе селектора. Если коллекцию пуста, возвращается null

maxOrNull(): Double? – Возвращает максимальное значение. Если коллекцию пуста, возвращается null

minOf(selector: (T) -> Double): Double – Возвращает минимальное значение на основе селектора

minOfOrNull(selector: (T) -> Double): Double? – Возвращает минимальное значение на основе селектора. Если коллекцию пуста, возвращается null

minOrNull(): Double? – Возвращает минимальное значение. Если коллекцию пуста, возвращается null

minus(element: T): List<T> – Возвращает новую коллекцию, которая содержит все элементы текущей за исключением элемента element.

Имеет разновидности, которую позволяют исключить из коллекции наборы элементов:

|<p>minus(elements: Array<T>): List<T></p><p>minus(elements: Iterable<T>): List<T></p><p>minus(elements: Sequence<T>): List<T></p>|
| :- |

plus(element: T): List<T> – Возвращает новую коллекцию, которая содержит все элементы текущей за исключением плюс элемент element.

Имеет разновидности, которую позволяют включить в коллекцию наборы элементов:

|<p>plus(elements: Array<T>): List<T></p><p>plus(elements: Iterable<T>): List<T></p><p>plus(elements: Sequence<T>): List<T></p>|
| :- |

reduce(operation: (acc: S, T) -> S): S – Возвращает значение, которое является результатом действия функции operation над каждым элементом коллекции. Первый параметр функции operation - результат работы функции над предыдущим элементом коллекции, в второй параметр - текущий элемент коллекции.

shuffled(): List<T> – Условно перемешивает коллекцию

sorted(): List<T> – Сортирует коллекцию по возрастанию

sortedBy(selector: (T) -> R?): List<T> – Сортирует коллекцию по возрастанию на основе селектора

sortedByDescending(selector: (T) -> R?): List<T> – Сортирует коллекцию по убыванию на основе функции-селектора

sortedDescending(): List<T> – Сортирует коллекцию по убыванию

sum(): Int – Возвращает сумму элементов коллекции.

subtract(other: Iterable): Set – Возвращает набор элементов, которые есть в текущей коллекции и отсутствуют в коллекции other.

sum(): Int – Возвращает сумму элементов коллекции

sumOf(selector: (T) -> Int): Int – Возвращает сумму элементов коллекции на основе функции-селектора

take(n: Int): List<T> – Возвращает новую коллекцию, которая содержит n первых элементов текущей коллекции

takeWhile(predicate: (T) -> Boolean): List<T> – Возвращает новую коллекцию, которая содержит n первых элементов текущей коллекции, соответствующих функции-предикату

toHashSet(): HashSet<T> – Создает из коллекции объект HashSet

toList(): List<T> – Создает из коллекции объект List

toMap(): Map<K, V> – Создает из коллекции объект Map

toSet(): Set<T> – Создает из коллекции объект Set

union(other: Iterable): Set – Возвращает набор уникальных элементов, которые есть в текущей коллекции и коллекции other
## List, MutableList
### Об List
List – последовательный неизменяемый список элементов, где элементы могут повторяться

Для создания применяется метод listOf()

Списки поддерживают перебор с помощью цикла for

### Методы List
Содержит методы из Iterable, Collection

Специфичные методы List:

get(index) – возвращает элемент по индексу (вместо метода get можно применять квадратные скобки)

getOrNull(index) – возвращает элемент по индексу; если индекс находится вне границ спика, то возвращает null

getOrElse(index: Int, defaultValue: (Int) -> T): T – возвращает элемент по индексу; если индекс находится вне границ списка, то вызывает функцию (второй параметр) и показывает её результат

subList(fromIndex: Int, toIndex: Int): List<E> – возвращает часть списка и в качестве параметров принимает первый и конечный индексы извлекаемых элементов

### Примеры
get(index):

|fun main() {<br>`    `val people = *listOf*("Tom", "Sam", "Kate", "Bob", "Alice")<br>`    `val first = people.get(0)<br>`    `val second = people.get(1)<br>`    `*println*(first)<br>`    `*println*(second)<br>}|
| :- |

getOrNull(index):

|fun main() {<br>`    `val people = *listOf*("Tom", "Sam", "Kate", "Bob", "Alice")<br>`    `val first = people.*getOrNull*(0)<br>`    `val second = people.*getOrNull*(10)<br>`    `*println*(first)<br>`    `*println*(second)<br>}|
| :- |

getOrElse(index: Int, defaultValue: (Int) -> T): T:

|fun main() {<br>`    `val people = *listOf*("Tom", "Sam", "Kate", "Bob", "Alice")<br>`    `val first = people.*getOrElse*(0) **{** "undefined" **}**<br>`    `val second = people.*getOrElse*(10) **{** "undefined ${**it**}" **}**<br>`    `*println*(first)<br>`    `*println*(second)<br>}|
| :- |

subList(fromIndex: Int, toIndex: Int): List<E>:

|fun main() {<br>`    `val people = *listOf*("Tom", "Sam", "Kate", "Bob", "Alice", "Mike")<br>`    `val subPeople = people.subList(1, 4)<br>`    `*println*(subPeople)<br>}|
| :- |

### Об MutableList
MutableList – последовательный изменяемый список элементов

Для создания применяется метод mutableListOf()

Списки поддерживают перебор с помощью цикла for

### Методы MutableList
Содержит методы из Iterable, MutableCollection

Специфичные методы MutableList:

add(index, element) – добавляет элемент по индексу

add(element) – добавляет элемент в конец

addAllCollection(collection) – добавляет коллекцию элементов в конец

remove(element) – удаляет элемент

removeAt(index) – удаляет элемент по индексу

clear() – удаляет все элементы коллекции

### Примеры

## Set, MutableSet
### Об Set
Set – последовательный неизменяемый список элементов, где каждый элемент является уникальным

Для создания применяется метод setOf()

Set поддерживает перебор с помощью цикла for

### Методы Set
Содержит методы из Iterable, Collection

Специфичные методы Set:

union(set) – объединение множеств

intersect(set) – пересечение множеств (возвращает элементы, которые есть в обоих подмножествах)

substract(set) – вычитание множеств (возвращает элементы, которые есть в первом множестве, но отсутствуют во втором)

### Примеры
### Об MutableSet
MutableSet – последовательный изменяемый список элементов, где каждый элемент является уникальным

Для создания применяется метод mutableSetOf()

MutableSet поддерживает перебор с помощью цикла for

### Методы MutableSet
Содержит методы из Iterable, MutableCollection

### Примеры
## Map, MutableMap
### Об Map
Map – набор пар ключ-значение, где каждый ключ является уникальным

Для создания применяется метод mapOf()

Map поддерживает перебор с помощью цикла for

### Методы Map
Содержит методы из Iterable, не содержит методы из Collection

Специфичные методы и свойства Map:

values – свойство; содержит в себе все значения Map

keys – свойство; содержит в себе все ключи Map

get(ключ) – получение значения по ключу; если нет элемента с указаным ключом, то возвращается null

getOrDefault(ключ, default) – получение значения по ключу; если нет элемента с указаным ключом, то возвращается default

getOrElse(ключ, функция) – получение значения по ключу; если нет элемента с указаным ключом, то вызывается фукция

containsKey(ключ) – позволяет проверить наличие ключа в Map

containsValue(зачение) – позволяет проверить наличие значения в Map

### Примеры
Перебор Map с помощью цикла for:

|fun main() {<br>`    `val peopleMap = *mapOf*(1 *to* "Tom", 5 *to* "Sam", 8 *to* "Bob")<br>`    `for(person in peopleMap){<br>`        `*println*("${person.key} - ${person.value}")<br>`    `}<br>`    `*println*(peopleMap)<br>}|
| :- |

### Об MutableMap
MutableMap – набор пар ключ-значение, где каждый ключ является уникальным

Для создания применяется метод mutableMapOf()

Map поддерживает перебор с помощью цикла for

### Методы MutableMap
put(key, value) – добавляет элемент с ключом key и значением value

putAll(коллекция) – добавляет элементы из указанной коллекции (объекты типа Array, Iterable, Sequence)

set(key, value) – устанавливает для элемента с ключом key значение value

remove(key) – удаляет элемент с ключом key (если удаление успешно, то возвращается значение удалённого элемента, иначе null)

remove(key, value) – удаляет элемент с ключом key, если он имеет значение value, и возвращает true, если элемент был успешно удалён

### Примеры

## Последовательности
### Об последовательности
Последовательность – последовательный изменяемый список элементов

Для создания применяется метод sequenceOf()

Последовательности поддерживают перебор с помощью цикла for

### Методы последовательности
generateSequence(функция) – принимает функцию, которая возвращает некоторое значение, это значение потом станет элементом последовательности

sequence(функция) – в этой функции можно генерировать элементы последовательности с помощью функций yield() и yieldAll()

yield(параметр) – возвращает во вне некоторое значение, которое ей передаётся через параметр

yieldAll(последовательность\_или\_коллекция) – возвращает во вне все значения коллекции или последовательности, которая ей передаётся через параметр

Основные методы последовательности:

all(predicate: (T) -> Boolean): Boolean – возвращает true, если все элементы соответствуют предикату, который передается в функцию в качестве параметра (терминальная операция)

any(): Boolean – возвращает true, если последовательность содержит хотя бы один элемент

any(predicate: (T) -> Boolean): Boolean – дополнительная версия возвращает true, если хотя бы один элемент соответствуют предикату, который передается в функцию в качестве параметра (терминальная операция)

average(): Double – возвращает среднее значение для числовой последовательности типов Byte, Int, Short, Long, Float, Double

chunked(size: Int): Sequence<List<T>> - расщепляет последовательность на последовательность из списков List, параметр size устанавливает максимальное количество элементов в каждом из списков

chunked(size: Int,transform: (List<T>) -> R): Sequence<R> - дополнительная версия в качестве второго параметра получает функцию преобразования, которая преобразует каждый список в элемент новой последовательности (промежуточная операция)

contains(element: T): Boolean – возвращает true, если последовательность содержит элемент element (терминальная операция)

count(): Int – возвращает количество элементов в последовательности

count(predicate: (T) -> Boolean): Int – дополнительная версия возвращает количество элементов, которые соответствуют предикату (терминальная операция)

distinct(): Sequence<T> – возвращает новую последовательность, которая содержит только уникальные элементы (промежуточная операция)

distinctBy(selector: (T) -> K): Sequence<T> – возвращает новую последовательность, которая содержит только уникальные элементы с учетом функции селектора, которая передается в качестве параметра (промежуточная операция)

drop(n: Int): Sequence<T> – возвращает новую последовательность, которая содержит все элементы за исключением первых n элементов (промежуточная операция)

dropWhile(predicate: (T) -> Boolean): Sequence<T>в– возвращает новую последовательность, которая содержит все элементы за исключением первых элементов, которые соответствуют предикату (промежуточная операция)

elementAt(index: Int): T – возвращает элемент по индексу index. Если индекс выходит за пределы последовательности, то генерируется исключение типа IndexOutOfBoundsException (терминальная операция)

elementAtOrElse(index: Int, defaultValue: (Int) -> T): T – возвращает элемент по индексу index. Если индекс выходит за пределы последовательности, то возвращается значение, устанавливаемое функцией из параметра defaultValue (терминальная операция)

elementAtOrNull(index: Int): T? – возвращает элемент по индексу index. Если индекс выходит за пределы последовательности, то возвращается null (терминальная операция)

filter(predicate: (T) -> Boolean): Sequence<T> – возвращает новую последовательность из элементов, которые соответствуют предикату – (промежуточная операция)

filterNot(predicate: (T) -> Boolean): Sequence<T> – возвращает новую последовательность из элементов, которые НЕ соответствуют предикату (промежуточная операция)

filterNotNull(): Sequence<T> – возвращает новую последовательность из элементов, которые не равны null (промежуточная операция)

find(predicate: (T) -> Boolean): T? – возвращает первый элемент, который соответствует предикату. Если элемент не найден, то возвращается null (терминальная операция)

findLast(predicate: (T) -> Boolean): T? – возвращает последний элемент, который соответствует предикату. Если элемент не найден, то возвращается null (терминальная операция)

first(): T – возвращает первый элемент последовательности

first(predicate: (T) -> Boolean): T – дополнительная версия возвращает первый элемент, которые соответствует предикату; если элемент не найден, то генерируется исключение типа NoSuchElementException (терминальная операция)

firstOrNull(): T? – возвращает первый элемент последовательности

firstOrNull(predicate: (T) -> Boolean): T? – дополнительная версия возвращает первый элемент, которые соответствует предикату; если элемент не найден, то возвращается null (терминальная операция)

flatMap(transform: (T) -> Sequence<R>): Sequence<R> – преобразует последовательность элементов типа T в последовательность элементов типа R, используя функцию преобразования, которая передается в качестве параметра (промежуточная операция)

fold(initial: R, operation: (acc: R, T) -> R): R – возвращает значение, которое является результатом действия функции operation над каждым элементом последовательности. Первый параметр функции operation - результат работы функции над предыдущим элементом последовательности (при первом вызове - значение из параметра initial), в второй параметр - текущий элемент последовательности. (терминальная операция)

forEach(action: (T) -> Unit) – выполняет для каждого элемента последовательности действие action. (терминальная операция)

groupBy(keySelector: (T) -> K): Map<K, List<T>> – группирует элементы по ключу, который возвращается функцией keySelector. Результат функции карта Map, где ключ - собственно ключ элементов, а значение - список List из элементов, которые соответствуют этому ключу

groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> – дополнительная версия принимает функцию преобразования элементов (терминальная операция)

indexOf(element: T): Int – возвращает индекс первого вхождения элемента element. Если элемент не найден, возвращается -1 (терминальная операция)

indexOfFirst(predicate: (T) -> Boolean): Int – возвращает индекс первого элемента, который соответствует предикату. Если элемент не найден, возвращается -1 (терминальная операция)

indexOfLast(predicate: (T) -> Boolean): Int – возвращает индекс последнего элемента, который соответствует предикату. Если элемент не найден, возвращается -1 (терминальная операция)

joinToString(): String – генерирует из последовательности строку (терминальная операция)

last(): T – возвращает последний элемент последовательности

last(predicate: (T) -> Boolean): T – дополнительная версия возвращает последний элемент, которые соответствует предикату; если элемент не найден, то генерируется исключение типа NoSuchElementException (терминальная операция)

lastOrNull(): T? – озвращает последний элемент последовательности

lastOrNull(predicate: (T) -> Boolean): T? – дополнительная версия возвращает последний элемент, которые соответствует предикату; если элемент не найден, то возвращается null (терминальная операция)

lastIndexOf(element: T): Int – возвращает последний индекс элемента element. Если элемент не найден, возвращается -1 (терминальная операция)

map(transform: (T) -> R): Sequence<R> – применяет к элементам последовательности функцию трансформации и возвращает новую последовательность из новых элементов (промежуточная операция)

mapIndexed(transform: (index: Int, T) -> R): Sequence<R> – применяет к элементам последовательности и их индексам функцию трансформации и возвращает новую последовательность из новых элементов (промежуточная операция)

mapNotNull(transform: (T) -> R?): Sequence<R> – применяет к элементам последовательности функцию трансформации и возвращает новую последовательность из новых элементов, которые не равны null (промежуточная операция)

maxOf(selector: (T) -> Double): Double – возвращает максимальное значение на основе селектора (терминальная операция)

maxOfOrNull(selector: (T) -> Double): Double? – возвращает максимальное значение на основе селектора. Если последовательность пуста, возвращается null (терминальная операция)

maxOrNull(): Double? – возвращает максимальное значение. Если последовательность пуста, возвращается null (терминальная операция)

minOf(selector: (T) -> Double): Double – возвращает минимальное значение на основе селектора (терминальная операция)

minOfOrNull(selector: (T) -> Double): Double? – возвращает минимальное значение на основе селектора. Если последовательность пуста, возвращается null (терминальная операция)

minOrNull(): Double? – возвращает минимальное значение. Если последовательность пуста, возвращается null (терминальная операция)

minus(element: T): Sequence<T>  – возвращает новую последовательность, которая содержит все элементы текущей за исключением элемента element; имеет разновидности, которую позволяют исключить из последовательности наборы элементов (промежуточная операция):

|<p>minus(elements: Array<T>): Sequence<T></p><p>minus(elements: Iterable<T>): Sequence<T></p><p>minus(elements: Sequence<T>): Sequence<T></p>|
| :- |

plus(element: T): Sequence<T> – возвращает новую последовательность, которая содержит все элементы текущей за исключением плюс элемент element; имеет разновидности, которую позволяют включить в последовательность наборы элементов (промежуточная операция):

|<p>plus(elements: Array<T>): Sequence<T></p><p>plus(elements: Iterable<T>): Sequence<T></p><p>plus(elements: Sequence<T>): Sequence<T></p>|
| :- |

reduce(operation: (acc: S, T) -> S): S – возвращает значение, которое является результатом действия функции operation над каждым элементом последовательности. Первый параметр функции operation - результат работы функции над предыдущим элементом последовательности, в второй параметр - текущий элемент последовательности. (терминальная операция)

shuffled(): Sequence<T> – условно перемешивает последовательность (промежуточная операция)

sorted(): Sequence<T> – сортирует последовательность по возрастанию (промежуточная операция)

sortedBy(selector: (T) -> R?): Sequence<T> – сортирует последовательность по возрастанию на основе селектора (промежуточная операция)

sortedByDescending(selector: (T) -> R?): Sequence<T> – сортирует последовательность по убыванию на основе функции-селектора (промежуточная операция)

sortedDescending(): Sequence<T> – сортирует последовательность по убыванию (промежуточная операция)

sum(): Int – возвращает сумму элементов последовательности. (терминальная операция)

sumOf(selector: (T) -> Int): Int – возвращает сумму элементов последовательности на основе функции-селектора (терминальная операция)

take(n: Int): Sequence<T> – возвращает новую последовательность, которая содержит n первых элементов текущей последовательности (промежуточная операция)

takeWhile(predicate: (T) -> Boolean): Sequence<T> – возвращает новую последовательность, которая содержит n первых элементов текущей последовательности, соответствующих функции-предикату (промежуточная операция)

toHashSet(): HashSet<T> – создает из последовательности объект HashSet (терминальная операция)

toList(): List<T> – создает из последовательности объект List (терминальная операция)

toMap(): Map<K, V> – создает из последовательности объект Map (терминальная операция)

toSet(): Set<T> – создает из последовательности объект Set (терминальная операция)

### Примеры

## Вопросы
Что такое элемент?

Что такое предикат?

Что такое селектор?

Что такое hashSet?

Что такое linkedHashSet?

Что такое it?
# ------
# viewBinding
viewBinding - это инструмент, который позволяет проще писать код для взаимодействия с элементами view

Чтобы включить viewBinding нужно прописать в build.gradle(app)

|<p>android {</p><p>`    `buildFeatures **{**<br>`        `viewBinding = true<br>`    `**}**</p><p>**}**</p>|
| :- |

Потом в MainActivity добавить следующее (чтобы получить доступ к view элементам):

|class MainActivity : AppCompatActivity() {<br>`    `lateinit var binding: ActivityMainBinding<br>`    `override fun onCreate(savedInstanceState: Bundle?) {<br>`        `super.onCreate(savedInstanceState)<br>`        `binding = ActivityMainBinding.inflate(*layoutInflater*)<br>`        `setContentView(binding.*root*)<br>`    `}<br>}|
| :- |

Его используют вместо findViewById

viewBinding быстрее работает чем findViewById

Как использовать viewBinding:

|<p>binding.textView.*text* = ""</p><p>binding.textView.append(text)</p>|
| :- |

# Room
## Как подключить к проекту
В build.gradle файл модуля добавить плагин kotlin-kapt:

|plugins **{**<br>`    `id 'kotlin-kapt'<br>**}**|
| :- |

В build.gradle файл модуля добавить зависимости плагина room:

|dependencies **{**<br>`    `// room<br>`    `def room\_version = "2.4.3"<br>`    `implementation("androidx.room:room-runtime:$room\_version")<br>`    `annotationProcessor("androidx.room:room-compiler:$room\_version")<br>`    `// To use Kotlin annotation processing tool (kapt)<br>`    `kapt("androidx.room:room-compiler:$room\_version")<br>`    `// To use Kotlin Symbol Processing (KSP)<br>`    `// ksp("androidx.room:room-compiler:$room\_version")<br>`    `// optional - Kotlin Extensions and Coroutines support for Room<br>`    `implementation("androidx.room:room-ktx:$room\_version")<br>`    `// optional - RxJava2 support for Room<br>`    `implementation("androidx.room:room-rxjava2:$room\_version")<br>`    `// optional - RxJava3 support for Room<br>`    `implementation("androidx.room:room-rxjava3:$room\_version")<br>`    `// optional - Guava support for Room, including Optional and ListenableFuture<br>`    `implementation("androidx.room:room-guava:$room\_version")<br>`    `// optional - Test helpers<br>`    `testImplementation("androidx.room:room-testing:$room\_version")<br>`    `// optional - Paging 3 Integration<br>`    `implementation("androidx.room:room-paging:$room\_version")<br>**}**|
| :- |

## Об room
Room – обёртка для работы с базой данных SQLite

Room имеет три основных компонента: Entity, Dao, Database

## Аннотация Entity
### Аннотация Entity
Аннотация Entity – необходимо пометить объект, который мы хотим хранить в базе данных

Имя класса, к которому мы будем применять аннотацию, будет по умолчанию использоваться в качестве имени таблицы

Имя таблицы можно вручную задать с помощью переменной tableName

Лучше всего для Entity использовать data класс

Пример (имя таблицы по умолчанию):

|@Entity<br>class Employee(var id: Long, var name: String, var salary: Int)|
| :- |

Пример (имя таблицы задано вручную):

|@Entity(tableName = "EmployeeName")<br>class Employee(var id: Long, var name: String, var salary: Int)|
| :- |

### Аннотация PrimaryKey
Аннотация PrimaryKey – помечаем поле, которое будет ключом в таблице; уникальный идентификатор для таблицы

Каждый класс, который будет использовать room, должен содержать хотя бы одно такое поле (даже если в классе всего одно поле)

Пример:

|@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey<br>`    `var id: Long,<br>`    `var name: String,<br>`    `var salary: Int<br>`    `)|
| :- |

### Аннотация PrimaryKey(autoGenerate = true)
Аннотация PrimatyKey(autoGenerate = true) – позволяет базе данных самой генерировать значение, если оно не указано в переменной

Пример:

|@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey(autoGenerate = true)<br>`    `var id: Long,<br>`    `var name: String,<br>`    `var salary: Int<br>`    `)|
| :- |

### Аннотация ColumnInfo(name)
Аннотация ColumnInfo(name = “name ”) – позволяет указать кастомное имя поля в таблице (по умолчанию используются имя переменных)

Пример:

|@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey<br>`    `var id: Long,<br>`    `@ColumnInfo(name = "full\_name")<br>`    `var name: String,<br>`    `var salary: Int<br>`    `)|
| :- |

### Аннотация ColumnInfo(typeAffinity)
Аннотация ColumnInfo(typeAffinity = TYPE) – позволяет указать кастомный тип поля в таблице (по умолчан. используется тип переменной)

Пример:

|@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey<br>`    `var id: Long,<br>`    `@ColumnInfo(name = "full\_name")<br>`    `var name: String,<br>`    `@ColumnInfo(typeAffinity = *TEXT*)<br>`    `var salary: Int<br>)|
| :- |

### Аннотация Embedded
Аннотация Embedded – позволяет использовать свойства обычного класса использовать в классе Entity

Таким образом свойства обычного класса просто добавятся в класс Entity

Пример:

|class Address(val city: String = "none", val street: String = "none", val number: Int = 0)<br><br>@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey(autoGenerate = true)<br>`    `var id: Long,<br>`    `@ColumnInfo(name = "full\_name")<br>`    `var name: String,<br>`    `@ColumnInfo(typeAffinity = *TEXT*)<br>`    `var salary: Int,<br>`    `@Embedded<br>`    `val addresses: Address<br>)|
| :- |

### Аннотация Embedded(prefix = “address”)
Аннотация Embedded(prefix = “address”) – используется в том случае, если имен свойств классов могут конфликтовать друг с другом; добавляет префикс к свойствам класса

Пример:

|class Address(val city: String = "none", val street: String = "none", val number: Int = 0)<br><br>@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey(autoGenerate = true)<br>`    `var id: Long,<br>`    `@ColumnInfo(name = "full\_name")<br>`    `var name: String,<br>`    `@ColumnInfo(typeAffinity = *TEXT*)<br>`    `var salary: Int,<br>`    `@Embedded(prefix = "address")<br>`    `val addresses: Address<br>)|
| :- |

### Аннотация Ignore
Аннотация Ignore – позволяет подсказать room, что это поле не должно записываться в базу или читаться из неё

Пример:

|class Address(val city: String = "none", val street: String = "none", val number: Int = 0)<br><br>@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey(autoGenerate = true)<br>`    `var id: Long,<br>`    `@ColumnInfo(name = "full\_name")<br>`    `var name: String,<br>`    `@ColumnInfo(typeAffinity = *TEXT*)<br>`    `var salary: Int,<br>`    `@Embedded(prefix = "address")<br>`    `val addresses: Address,<br>`    `@Ignore<br>`    `var avatar: String<br>)|
| :- |

## Аннотация Dao
### Аннотация Dao
Аннотация Dao – помечаем ИНТЕРФЕЙС, в котором мы будем описывать методы для работы с базой данных (например, получение списка сотрудников, добавление, изменение, удаление сотрудников)

Пример:

|@Dao<br>interface EmployeeDao {}|
| :- |

### Аннотация Insert
Аннотация Insert – используется для вставки объекта в базу данных; на вход должна принимать Entity объект; применяется для метода

Имя метода можно использовать любое, но удобнее будет использовать insert

Пример:

|class Address(val city: String = "none", val street: String = "none", val number: Int = 0)<br><br>@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey(autoGenerate = true)<br>`    `var id: Long,<br>`    `@ColumnInfo(name = "full\_name")<br>`    `var name: String,<br>`    `@ColumnInfo(typeAffinity = *TEXT*)<br>`    `var salary: Int,<br>`    `@Embedded(prefix = "address")<br>`    `val addresses: Address,<br>`    `@Ignore<br>`    `var avatar: String<br>)<br><br>@Dao<br>interface EmployeeDao {<br>`    `@Insert<br>`    `fun insert(employee: Employee)<br>}|
| :- |

При вызове метода insert, он может возвращать id только что добавленной записи

Для этого нужно описать метод так, чтобы он возвращал Long

Пример:

|class Address(val city: String = "none", val street: String = "none", val number: Int = 0)<br><br>@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey(autoGenerate = true)<br>`    `var id: Long,<br>`    `@ColumnInfo(name = "full\_name")<br>`    `var name: String,<br>`    `@ColumnInfo(typeAffinity = *TEXT*)<br>`    `var salary: Int,<br>`    `@Embedded(prefix = "address")<br>`    `val addresses: Address,<br>`    `@Ignore<br>`    `var avatar: String<br>)<br><br>@Dao<br>interface EmployeeDao {<br>`    `@Insert<br>`    `fun insert(employee: Employee): Long<br>}|
| :- |

### Аннотация Insert(onConflict)
Аннотация Insert(onConflict = OnConflictStrategy.REPLACE) – если в базе уже есть такая запись, то она перезапишется новой

По умолчанию, если в базе уже есть такая запись, то возникнет ошибка

Пример:

|class Address(val city: String = "none", val street: String = "none", val number: Int = 0)<br><br>@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey(autoGenerate = true)<br>`    `var id: Long,<br>`    `@ColumnInfo(name = "full\_name")<br>`    `var name: String,<br>`    `@ColumnInfo(typeAffinity = *TEXT*)<br>`    `var salary: Int,<br>`    `@Embedded(prefix = "address")<br>`    `val addresses: Address,<br>`    `@Ignore<br>`    `var avatar: String<br>)<br><br>@Dao<br>interface EmployeeDao {<br>`    `@Insert(onConflict = OnConflictStrategy.*REPLACE*)<br>`    `fun insert(employee: Employee): Long<br>}|
| :- |

### Аннотация Update
Аннотация Update – используется для обновления объекта в БД; на вход должна принимать Entity объект; применяется для метода

Имя метода можно использовать любое, но удобнее будет использовать Update

Пример:

|class Address(val city: String = "none", val street: String = "none", val number: Int = 0)<br><br>@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey(autoGenerate = true)<br>`    `var id: Long,<br>`    `@ColumnInfo(name = "full\_name")<br>`    `var name: String,<br>`    `@ColumnInfo(typeAffinity = *TEXT*)<br>`    `var salary: Int,<br>`    `@Embedded(prefix = "address")<br>`    `val addresses: Address,<br>`    `@Ignore<br>`    `var avatar: String<br>)<br><br>@Dao<br>interface EmployeeDao {<br>`    `@Insert(onConflict = OnConflictStrategy.*REPLACE*)<br>`    `fun insert(employee: Employee): Long<br>    <br>`    `@Update<br>`    `fun update(employee: Employee)<br>}|
| :- |

При вызове метода update, он может возвращать количество обновлённых записей

Для этого нужно описать метод так, чтобы он возвращал Int

Пример:

|class Address(val city: String = "none", val street: String = "none", val number: Int = 0)<br><br>@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey(autoGenerate = true)<br>`    `var id: Long,<br>`    `@ColumnInfo(name = "full\_name")<br>`    `var name: String,<br>`    `@ColumnInfo(typeAffinity = *TEXT*)<br>`    `var salary: Int,<br>`    `@Embedded(prefix = "address")<br>`    `val addresses: Address,<br>`    `@Ignore<br>`    `var avatar: String<br>)<br><br>@Dao<br>interface EmployeeDao {<br>`    `@Insert(onConflict = OnConflictStrategy.*REPLACE*)<br>`    `fun insert(employee: Employee): Long<br><br>`    `@Update<br>`    `fun update(employee: List<Employee>): Int<br>}|
| :- |

### Аннотация Update(onConflict)
Аннотация Update тоже поддерживает параметр onConflict

### Аннотация Delete
Аннотация Delete – используется для удаления объекта из БД; на вход должна принимать Entity объект; применяется для метода

Имя метода можно использовать любое, но удобнее будет использовать Delete

Пример:

|class Address(val city: String = "none", val street: String = "none", val number: Int = 0)<br><br>@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey(autoGenerate = true)<br>`    `var id: Long,<br>`    `@ColumnInfo(name = "full\_name")<br>`    `var name: String,<br>`    `@ColumnInfo(typeAffinity = *TEXT*)<br>`    `var salary: Int,<br>`    `@Embedded(prefix = "address")<br>`    `val addresses: Address,<br>`    `@Ignore<br>`    `var avatar: String<br>)<br><br>@Dao<br>interface EmployeeDao {<br>`    `@Insert(onConflict = OnConflictStrategy.*REPLACE*)<br>`    `fun insert(employee: Employee): Long<br><br>`    `@Update<br>`    `fun update(employee: List<Employee>): Int<br>    <br>`    `@Delete<br>`    `fun delete(employee: Employee)<br>}|
| :- |

При вызове метода delete, он может возвращать количество удалённых записей

Для этого нужно описать метод так, чтобы он возвращал Int

Пример:

|class Address(val city: String = "none", val street: String = "none", val number: Int = 0)<br><br>@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey(autoGenerate = true)<br>`    `var id: Long,<br>`    `@ColumnInfo(name = "full\_name")<br>`    `var name: String,<br>`    `@ColumnInfo(typeAffinity = *TEXT*)<br>`    `var salary: Int,<br>`    `@Embedded(prefix = "address")<br>`    `val addresses: Address,<br>`    `@Ignore<br>`    `var avatar: String<br>)<br><br>@Dao<br>interface EmployeeDao {<br>`    `@Insert(onConflict = OnConflictStrategy.*REPLACE*)<br>`    `fun insert(employee: Employee): Long<br><br>`    `@Update<br>`    `fun update(employee: List<Employee>): Int<br><br>`    `@Delete<br>`    `fun delete(employee: List<Employee>): Int<br>}|
| :- |

### Аннотация Transaction
Аннотация Transaction – позволяет выполнить несколько методов за раз

Пример:

|class Address(val city: String = "none", val street: String = "none", val number: Int = 0)<br>class Car(val carName: String = "none")<br><br>@Entity(tableName = "EmployeeName")<br>class Employee(<br>`    `@PrimaryKey(autoGenerate = true)<br>`    `var id: Long,<br>`    `@ColumnInfo(name = "full\_name")<br>`    `var name: String,<br>`    `@ColumnInfo(typeAffinity = *TEXT*)<br>`    `var salary: Int,<br>`    `@Embedded(prefix = "address")<br>`    `val addresses: Address,<br>`    `@Ignore<br>`    `var avatar: String<br>)<br><br>@Dao<br>interface EmployeeCarDao {<br>`    `@Insert(onConflict = OnConflictStrategy.*REPLACE*)<br>`    `fun insertEmployee(employee: Employee): Long<br>`    `@Insert(onConflict = OnConflictStrategy.*REPLACE*)<br>`    `fun insertCar(car: Car): Long<br>`    `@Transaction<br>`    `fun insertEmployeeAndCar(employee: Employee, car: Car) {<br>`        `insertEmployee(employee)<br>`        `insertCar(car)<br>`    `}<br>}|
| :- |

## Аннотация Database
### Аннотация Database
Аннотация Database – абстрактный класс, который даёт доступ к БД, либо создаёт её, если она ещё не создана

Этот класс должен быть абстрактным и наследовать RoomDatabase

В параметрах аннотации Database нужно указать какие Entity будут использоваться и версию БД

В Database классе нужно описать абстрактные методы для получения Dao объектов, которые мне понадобятся

|@Database(entities = [EmployeeEntity::class], version = 1)<br>abstract class MainDb: RoomDatabase() {<br>`    `abstract fun getDao(): EmployeeDao<br>`    `companion object {<br>`        `fun getDb(context: Context): MainDb {<br>`            `return Room.databaseBuilder(<br>`                `context.*applicationContext*,<br>`                `MainDb::class.*java*,<br>`                `"test.db"<br>`            `).build()<br>`        `}<br>`    `}<br>}|
| :- |

## Как создать бд в приложении
Нужно создать класс ентити, через который можно будет записывать в бд значения

|package com.example.firstapp<br><br>import androidx.room.\*<br><br>@Entity(tableName = "EmployeeName")<br>data class EmployeeEntity(<br>`    `@PrimaryKey(autoGenerate = true)<br>`    `var id: Int?,<br>`    `@ColumnInfo(name = "fullName")<br>`    `var name: String,<br>`    `@ColumnInfo(typeAffinity = ColumnInfo.*TEXT*)<br>`    `var salary: String,<br>)|
| :- |

Нужно создать класс дао, через который можно будет управлять значениями в бд

|package com.example.firstapp<br><br>import androidx.room.\*<br>import kotlinx.coroutines.flow.Flow<br><br>@Dao<br>interface EmployeeDao {<br>`    `@Insert(onConflict = OnConflictStrategy.*REPLACE*)<br>`    `fun insert(employee: EmployeeEntity): Long<br>`    `@Update<br>`    `fun update(employee: List<EmployeeEntity>): Int<br>`    `@Delete<br>`    `fun delete(employee: List<EmployeeEntity>): Int<br>`    `@Query("SELECT \* FROM EmployeeName")<br>`    `fun getAll(): Flow<List<EmployeeEntity>><br>`    `@Query("DELETE FROM EmployeeName")<br>`    `fun deleteAll()<br>}|
| :- |

Нужно создать основной класс, который даёт доступ к бд, либо создаёт её, если она ещё не создана

|package com.example.firstapp<br><br>import androidx.room.\*<br>import android.content.Context<br><br><br>@Database(entities = [EmployeeEntity::class], version = 1)<br>abstract class MainDb: RoomDatabase() {<br>`    `abstract fun getDao(): EmployeeDao<br>`    `companion object {<br>`        `fun getDb(context: Context): MainDb {<br>`            `return Room.databaseBuilder(<br>`                `context.*applicationContext*,<br>`                `MainDb::class.*java*,<br>`                `"test.db"<br>`            `).build()<br>`        `}<br>`    `}<br>}|
| :- |

Создать объект БД (в MainActivity):

|val db = MainDb.getDb(this)|
| :- |

# Dagger 2
## Как подключить к проекту
В build.gradle файл модуля добавить плагин kotlin-kapt:

|plugins **{**<br>`    `id 'kotlin-kapt'<br>**}**|
| :- |

В build.gradle модуля добавить dependencies:

|<p>implementation 'com.google.dagger:dagger:2.34'</p><p>kapt 'com.google.dagger:dagger-compiler:2.34'</p>|
| :- |

## Об dagger 2
Dagger 2 – фреймворк, аннотации; управляет зависимостями (в данном случае зависимости это классы, которые нужны для работы других классов)

Даггер состоит из Модуля и Компонента:

Модуль – это класс, который содержит метод, который описывает каким образом нужно создать объект и возвращает его

Компонент – это интерфейс, который содержит методы, которые возвращают объекты

Пример создания Компонента и Модуля:

|package com.example.experiments<br><br>import dagger.Component<br>import dagger.Module<br>import dagger.Provides<br><br>@Component(modules = [StorageModule::class, NetworkModule::class])<br>interface AppComponent {<br>`    `fun getDatabaseHelper(): DatabaseHelper<br>`    `fun getNetworkUtils(): NetworkUtils<br>}<br><br>@Module<br>class StorageModule {<br>`    `@Provides<br>`    `fun provideDatabaseHelper(): DatabaseHelper {<br>`        `return DatabaseHelper()<br>`    `}<br>}<br><br>@Module<br>class NetworkModule {<br>`    `@Provides<br>`    `fun provideNetworkUtils(): NetworkUtils {<br>`        `return NetworkUtils()<br>`    `}<br>}|
| :- |

Пример использования Компонента и Модуля:

|package com.example.experiments<br><br>import android.os.Bundle<br>import androidx.appcompat.app.AppCompatActivity<br>import com.example.experiments.databinding.ActivityMainBinding<br><br>class MainActivity : AppCompatActivity() {<br>`    `private lateinit var binding: ActivityMainBinding<br>`    `override fun onCreate(savedInstanceState: Bundle?) {<br>`        `super.onCreate(savedInstanceState)<br>`        `binding = ActivityMainBinding.inflate(*layoutInflater*)<br>`        `setContentView(binding.*root*)<br><br>`        `// 1 создаём объект компонента<br>`        `val appComponent = DaggerAppComponent.create()<br>`        `// 2 создаём объект DatabaseHelper<br>`        `val databaseHelper = appComponent.getDatabaseHelper()<br>`        `// обрабатываем событые на клике по кнопке<br>`        `var i: Int = 0<br>`        `val button = binding.button<br>`        `button.setOnClickListener **{**<br>`            `if (i == 0) {<br>`                `// 3 пользуемся объектом DatabaseHelper<br>`                `binding.textView.*text* = databaseHelper.sayHello()<br>`                `i = 1<br>`            `}<br>`            `else {<br>`                `binding.textView.*text* = "Click"<br>`                `i = 0<br>`            `}<br>`        `**}**<br>`    `}<br>}|
| :- |

Пример использования инжектирования:

|package com.example.experiments<br><br>import dagger.Component<br>import dagger.Module<br>import dagger.Provides<br><br>@Component(modules = [StorageModule::class, NetworkModule::class])<br>interface AppComponent {<br>`    `fun getDatabaseHelper(): DatabaseHelper<br>`    `fun getNetworkUtils(): NetworkUtils<br>`    `fun injectMainActivity(mainActivity: MainActivity)<br>}<br><br>@Module<br>class StorageModule {<br>`    `@Provides<br>`    `fun provideDatabaseHelper(): DatabaseHelper {<br>`        `return DatabaseHelper()<br>`    `}<br>}<br><br>@Module<br>class NetworkModule {<br>`    `@Provides<br>`    `fun provideNetworkUtils(): NetworkUtils {<br>`        `return NetworkUtils()<br>`    `}<br>}|
| :- |

# Android SDK
RoadMap:

Что нужно учить и в какой очерёдности

В первую очередь нужно учить котлин

После этого из чего состоит проект, что такое xml, основные контейнеры и вьюшки и их атрибуты

А дальше что?


Понимать как работает REST, TCP/IP, TLS/SSL, HTTP, HTTPS

Понимать как работает DB, SQL, MySQL

Для тестирования: JUnit, Espresso

Для управления зависимостями: Dagger, Dagger2, coin

Система автоматической сборки: Gradle

Также научиться подключаться к другим сервисам через API

Для работы с сетевыми запросами: Retrofit,Okhttp

Для работы с изображениями: Glide


Room, Retrofit, Dagger, Hilt, RecyclerView, Android Application Components
## Об Android SDK
Android SDK – комплект средств разработки под Android

Что входит в Android SDK:

Platform Tools (adb, fastboot, systrace и т.д.)

Buils Tools (zipalign, a apt2, apksigner)

Android Emulator (виртуальное устройство android)

Libraries (встроенные библиотеки от google)

ADB – помогает найти ошибки в работе приложений, установить APK на смартфон

Fastboot – активировать быструю загрузку для управления смартфоном с компьютера, перепрошить гаджет, настроить доступ, параметры работы операционной системы

Systrace – получить информацию о запущенных процессах, проследить за активностью и объёмом данных, которые отправлены по сети

Zipalign – позволяет оптимизировать файл APK, AAPT2 (проанализировать и скомпилировать ресурсы в двоичный формат под Android)

Apksigner – подписать пакет APK с помощью закрытого ключа
## XML
### Об XML
XML – описывает как будет выглядеть приложение; можно использовать для построения макетов; описывает как будут размещены элементы на экране, какие элементы будут размещены на экране

XML синтаксис для View:

Всегда начинаем с <ИмяЭлемента

Указываем атрибуты элемента

Объявляем конец с помощью />

XML синтаксис для ViewGroup:

Всегда начинаем с <ИмяЭлемента

Потом идёт список атрибутов по одному на строку

Заканчиваем открывающий тег с помощью >

Затем вставляем в ViewGroup элементы View

Объявляем конец ViewGroup с помощью закрывающего тега </ИмяЭлемента>

### Определить интерфейс в коде
Чтобы создать виджет (объект View) в коде нужно:

\1. Объявить объект виджета, передать конструктору контекст (android.content.Context)

\2. Присвоить этому объекту ширину, высоту и т.п.

\3. Установить этот объект в качестве UI приложения, то есть передать объект с помощью метода setContentView(объект)

Чтобы создать контейнер (объект ViewGroup) в коде нужно:

\1. Создать контейнер (Имя\_контейнера.LayoutParams имя\_переменной, передать в конструктор ширину и высоту)

\2. Присвоить этому контейнеру выравнивание левого края, выравнивание вернего края т.п.

\3. Передать те же параметры выравнивания объекту View (имя.setLayoutParams(имя\_объекта\_ViewGroup))

\4. Установить этот объект ViewGroup в качестве UI приложения, то есть передать объект с помощью метода setContentView(объект\_ViewGroup)

setContentView – устанавливает объект в качестве UI приложения, принадлежит классу Activity
### Определить интерфейс в XML
XML – файл, который хранит в себе определение визуального интерфейса в виде XML кода (как HTML)

Такие файлы хранятся в каталоге res/layout

При создании разметки следует соблюдать некоторое правило: каждый файл разметки должен содержать только один корневой элемент (корневым элементом должен быть объект View или VIewGroup)

Что находится внутри файла XML:

xmlns:android – содержит основные атрибуты в виде констант (например, размер, позиционирование)

xmlns:app – содержит атрибуты в виде констант, которые определены в рамках приложения

xmlns:tools – применяется для работы в режиме дизайнера в Android Studio (атрибуты в этом пространстве имён будут определёны только в рамках студии и их значения будут показываться только там)

При компиляции каждый XML файл компилируется в ресурс View

Загрузка ресурса разметки осуществляется в методе Activity.onCreate()

Чтобы применить разметку для текущего Activity, нужно в метод setContentView() в качестве параметра передать ссылку на ресурс разметки (R.layout.имя\_разметки - R.layout.activity\_main)

Как правило, каждый отдельный класс Activity использует свой файл layout

Но для одного класса Activity можно использовать сразу несколько файлов layout

## Атрибуты
### Об атрибутах
Атрибуты – характеристики, которые определяют способы отображения элемента (ширина, высота, размер, padding, margin и многие другие)
### Отступы (padding, margin)
padding (отступ от контейнера к элементу)

margin (отступ от элемента к контейнеру; элемент должен быть в контейнере; можно применять только к отдельной стороне)

### Размеры (px, dp, sp, pt, mm, in)
Для размеров View, ViewGroup рекомендуется использовать dp

Для размера шрифта текста рекомендуется использовать sp

Виды размеров:

px – пиксели текущего экрана (не рекомендуется)

dp – независимые от плотности экрана пиксели; абстрактная единица измерения, основанная на физической плотности экрана с разрешением 160 точек на дюйм (dpi), то есть 1dp = 1px; если размер экрана больше или меньше чем 160dpi, соответственно и количество реальных пикселей будет менятся; общая формула: px = dp \* (dpi / 160)

sp – независимые от масштабирования пиксели (рекомендуется для работы с размерами шрифтов)

pt – 1/72 дюйма, базируются на физических размерах экрана

mm – миллиметры

in – дюймы

Группы размеров (для упрощения работы с ними):

ldpi (low) – примерно 120dpi

mdpi (medium) – примерно 160dpi

hdpi (high) – примерно 240dpi

xhdpi (extra high) – примерно 320dpi

xxhdpi (extra extra high) – примерно 480dpi

xxxhdpi (extra extra extra high) – примерно 640 dpi

### Ширина, высота (height, width, wrap, match)
layout\_height – устанавливает высоту View или ViewGroup

layout\_width – устанавливает ширину View или ViewGroup

wrap\_content – ширина View подстраивается так, чтобы быть точно равной ширине и высоте контента внутри неё

match\_content – растяжение внутреннего контейнера по всей ширине или высоте внешнего контейнера

(можно использовать match\_parent (для всех контейнеров, кроме ConstraintLayout) или 0dp (для ConstraintLayout))

minHeight, maxHeight и minWidth, maxWidth– установка минимальных и максимальных значений

### Позиционирование (left, right, above, below)
layoutToLeftOf – слева от элемента

layoutToRightOf – справа от элемента

layout\_above – сверху от элемента

layout\_below – снизу от элемента

android:id=”@+id/имя\_идентификатора” – создать уникальное имя для элемента

### Вес (weight)
layout\_weight – устанавливает вес для элемента; если для всех элементов назначить одинаковый вес, то они будут равномерно распределены по экрану; по умолчанию weight равно нулю

Для LinearLayout:

Если orientation == vertical, значит высоту нужно задать нулевой, а после указать вес

Если orientation == horizontal, значит ширину нужно задать нулевой, а после указать вес

## Layout
Layout – макет экрана; состоит из разных View и ViewGroup

## View
### Об View
View – это прямоугольник на экране, показывающий некое содержание (это может быть картинка, текст, кнопка …)

### Жизненный цикл View
https://tuhub.ru/posts/realizatsiya-custom-view-komponenta-v-android

взять инфу из этого сайта
### TextView
TextView – View, показывающий какой-либо текст

### ImageView
ImageView – View, содержащий картинку

### Button
Button(onClick) – View с кнопкой
### CheckBox
## ViewGroup
### Об ViewGroup
ViewGroup – прямоугольник на экране, которые содержит другие View или ViewGroup

### LinearLayout
LinearLayout – можно выставить вертикальный столбец или горизонтальный ряд (строго один за другим)

Содержит атрибут orientation, которые означает как будут отображаться элементы – горизонтально или вертикально

Список обязательных атрибутов (и их значение по умолчанию):

Список самых популярных атрибутов (и их значение по умолчанию):

Список всех атрибутов (и их значение по умолчанию):

Примеры:

### RelativeLayout
RelativeLayout – можно выставить одни дочерние элементы относительно других (относительно друг друга)

Список самых популярных атрибутов (значение по умолчанию: “true”, “false”):

android:layout\_alignParentTop

android:layout\_alignParentBottom

android:layout\_alignParentLeft

android:layout\_alignParentRight

android:layout\_centerHorizontal

android:layout\_centerVertical

Список всех атрибутов (и их значение по умолчанию):

Примеры:

### ConstraintLayout
ConstraintLayout – устаревший layout, который лучше уже не использовать

Список самых популярных атрибутов (и их значение по умолчанию):

Список всех атрибутов (и их значение по умолчанию):

Примеры:

## Resources
Ресурсы – файл, который содержит какие-то определённые данные (разметка, строки, изображения, файлы)

Все ресурсы находятся в проекте в каталоге res

Для различных типов ресурсов, определённых в проекте, в каталоге res можно создавать подкаталоги

В коде ресурсы передаются в таком виде: R.тип\_ресурсы.имя\_ресурса

В XML ресурсы передаются в таком виде: @тип\_ресурса/имя\_ресурса

## Activity
### Об Activity
Activity – отдельный экран в Android

Activity помогает мне разместить все мои компоненты пользовательского интерфейса или виджеты на экране

Когда Activity меняет стадию, он вызывает один из методов жизненного цикла для класса Activity

### Методы жизненного цикла Activity
onCreate(): вызывается при первой инициализации Activity (этот метод нужно выполнить для любой инициализации в моей Activity)

onStart(): вызывается когда Activity готова и отображается пользователю в первый раз (Activity готовится стать интерактивной и выйти на передний план; после завершения вызова этого метода будет вызван метод onResume())

onResume(): когда Activity переходит в это состояние, оно начинает взаимодействовать с пользователем (Activity продолжает работать в этом состоянии, пока что либо не уведёт фокус от приложения или Activity, например входящий звонок, если это произойдет, будет вызван метод onPause())

onPause(): используется для приостановки действий, которые не должны происходить, пока Activity в стадии паузы (вызов этого метода указывает на то, что пользователь покинул приложение, к примеру, входящий звонок может перевести проигрыватель музыки в состояние паузы; когда пользователь возвращается в приложение, вызывается метод onResume())

onStop(): метод вызывается, когда Activity больше не видна в приложении (такое может случится, если подгружена другая Activity и она занимает весь экран; при вызове этого метода Activity сообщается перейти в состояние прекращения работы; в этом состоянии система либо вызывает onRestart() для возврата взаимодействия с Activity, либо вызывает метод onDestroy(), чтобы убрать Activity)

onDestroy(): метод вызывается перед тем, как Activity будет завершена (система вызывает этот метод, когда пользователь завершает Activity или, если система временно убирает процесс, содержащий Activity для освобождения памяти; с этим методом обязательно нужно освободить все ресурсы, созданные Activity, иначе приложение будет иметь утечку памяти)

onRestart(): вызывается после того, как Activity было приостановлено; перезагрузка Activity

Жизненный цикл активити в виде блоксхемы 1:

![](Aspose.Words.03b2346a-e53d-439c-8d4c-28410946bacc.001.png)

Жизненный цикл активити в виде блоксхемы 2:

![](Aspose.Words.03b2346a-e53d-439c-8d4c-28410946bacc.002.png)
### Методы Activity


## Intent
Intent – это объект, который обеспечивает связывание отдельных компонент во время выполнения (например, двух активити)

Intent – представляет намерение что-то сделать

Intent – можно использовать для широкого круга задач, но чаще всего используется для запуска другой активити

Intent – механизм для описания одной операции (выбрать фотографию, отправить письмо, сделать звонок)

## Вопросы
### Как XML связать с кодом?
### Про файл manifest
# Разное про Android SDK
## Официальные библиотеки (от Google):
AndroidX (Jetpack (Compose))

AndroidX – значительно усовершенствованная библиотека поддержки (Support LIbrary) Android, исходная версия которой больше не поддерживается

Jetpack – включает в себя набор библиотек Android, которые включают в себя лучшие практики и обеспечивают обратную совместимость в приложениях Android

Compose – представляет современныё тулкит от компании Google для создания приложений под Android на языке Kotlin

## Неофициальные библиотеки (сторонние)
Для работы с сетевыми запросами: Retrofit,Okhttp

Для работы с изображениями: Glide 

В качестве БД в Android обычно используют SQlite, для взаимодействия с ней есть удобная библиотека Room

Последнее время есть запрос на сервисы Firebase. Там есть различные базы данных, система авторизации, аналитика и т.д. 

Сервисы основаны на облачных технологиях, позволяют собрать простой бэкенд  для не очень сложных приложений. 

Для DI: Dagger 2, Dagger Hilt. Dagger Hilt  приятнее имхо.

Еще всякие гугловские библиотеки можно посмотреть, google maps,например

Для реактивного программирования: Kotlin Flows, многие используют RxJava/RxKotlin.

Но я думаю, чтобы погружаться в Android, не надо ничего целенаправленно изучать отдельно от написания приложений

Glide – для создания прогрессивных веб приложений

Retrofit – REST клиент для Java и Android; библиотека для сетевого взаимодействия; библиотека для взаимодействия с сервером

Rest API – способ взаимодейтсвия сайтов и веб приложений с сервером

GSON – библиотека, которая позволяет конвертировать объекты JSON в объекты Java и наоборот

Firebase – облачная база данных, которая позволяет пользователям хранить и получать сохранённую информацию

RxJava -  это комбинация лучших идей шаблонов проектирования Наблюдатель и Итератор; позволяет наблюдать за чем-то и когда оно изменится – взаимодействовать с этим

Java, Kotlin

AndroidX, SQLite, Room


## Основы создания интерфейса
Каким способом можно определить интерфейс:

Можно определить в коде

Можно определить в файле XML

Можно использовать смешанный способ

Графический интерфейс строится из иерархии объектов android.view.View и android.view.ViewGroup

Каждый объект ViewGroup это контейнер для дочерних объектов View или других ViewGroup

Простые объекты View это виджеты, а то есть: элементы управления, кнопки, текстовые поля, и т.д. (с помощью них пользователь взаимодействует с приложением)

Большинство визуальных элементов (подклассов от View) располагаются в пакете android.widget

## Логгирование
Log.v(“сообщение”)

## Полезные горячие клавиши
Ctrl + Shift + H – показать информацию про метод

Ctrl + Shift + O – импортирование недостающих классов

Ctrl + Alt + L – автовыравнивание кода

Добавить способ комментирования кода и раскомментирования
## Правила написания кода
Названия методов пишутся с помощью верблюжегоРегистра

Названия констант пишутся только ЗАГЛАВНЫМИ буквами
## Приложение, виды приложений
Виды приложений: приложение переднего плана, фоновые приложения, смешанные приложения, виджеты

RxJava
# Про MVVM, MVI, MVP
Архитектура приложения – позволяет строить приложение по заранее выбраному шаблону (чтобы повысить читаемость кода, вследствии чего его легко будет расширять, легко будет тестировать)

MVC


## Model View Controller (Passive Viev):
Для андроид MVC используется только Passive View модель

Представление – визуальная проекция модели; отвечает за отображение данных модели пользователю

Контроллер – соединение между пользователем и системой; интерпретирует действия пользователя; обрабатывает команды из других приложений или операционной системы 

Главная идея:

Представление полностью управляется контроллером

Код чётко разделён на два уровня: логика отображения и бизнес логика

Логика отображения – то, как выглядит приложение

Бизнес логика – то, как работает приложение

Практическое примение:


## Model View Presenter:
Model – представляет собой данные, которые необходимо показать пользователю (в большинстве android приложений Model выступает слой, отвечающий за получение данных с бэкэнда)

View – класс, отвечающий за отображение данных (в android приложениях View это обычно Activity или Fragment) (View слушает пользовательские ивенты и делегирует их обработку в Presenter)

Presenter – класс, который имеет ссылки на Model и View (отвечает за обработку ивентов, приходящих из View, получение данных из Model и обновление View с полученными данными) (считается хорошей практикой делать Presenter независимым от Android SDK)

В чем отличие MVC от MVP:

Model View Controller:

Controller – отвечает за поведение программы, может быть использован несколькими View

View – может общаться напрямую с Model

Model View Presenter:

View – больше отделено от Model

Presenter – посредник между View и Model

Проще делать Unit тесты

Реагирует на действия пользователя и обновления Model

Можно использовать несколько Presenter для сложных View







## Другое описание
Model – под Model обычно понимается часть содержащая в себе функциональную бизнес логику приложения; Model должен быть полностью независим от остальных частей продукта; слой Model ничего не должен знать об элементах дизайна, и каким образом он будет отображаться; достигается результат, позволяющий менять представление данных, то как они отображаются, не трогая сам Model

Признаки Model:

Model – это бизнес логика приложения

Model обладает знаниями о себе самой и не знает о Controller и View

Для некоторых проектов Model это просто слой данных (база данных, XML файл)

Для других проектов Model это менеджер базы данных, набор объектов или просто логика приложения

View – в обязанности View входит отображение данных полученных из Model; View не может напрямую влиять на Model; View обладает доступом только на чтение к данным

Признаки View:

В View реализуется отображение данных, которые получаются из Model любым способом

В некоторых случаях View может иметь код, который реализует некоторую бизнес логику

## Model-View-Presenter:
Данный подход позволяет создавать абстракцию View

Для этого нужно создать интерфейс View с определённым набором свойств и методов

Presenter, в свою очередь, получает ссылку на реализацию интерфейса, подписывается на события View и по запросу изменяет Model

Признаки Presenter:

Двухсторонняя коммуникация с View

View взаимодействует напрямую с Presenter, путём вызова соответствующих фукнций или событий Presenter

Presenter взаимодействует с View путём использования специального интерфейса, реализованного с помощью View

Один экземпляр Presenter связан с одним View

Реализация:

Каждое View должно реализовывать соответствующий интерфейс. Интерфейс View определяет набор функций и событий, необходимых для взаимодействия с пользователем. Presenter должен иметь ссылку на реализацию соответствующего интерфейса, которую обычно передают в конструкторе. Логика View должна иметь ссылку на экземпляр Presenter. Все события View передаются для обработки в Presenter и практически никогда не обрабатываются логикой View (в том числе создания других представлений)

## Model-View-View Model:
Данный подход позволяет связывать элементы представления со свойствами и событиями View Model

Можно утверждать, что каждый слой этого паттерна не знает о существовании другого слоя

Признаки View Model:

Двухсторонняя коммуникация с View

View Model это абстракция View; обычно означает, что свойства View обычно совпадают со свойствами View Model

View Model не имеет ссылки на интерфейс View; изменение состояния View Model автоматически изменяет View и наоборот, поскольку используется механизм связывания данных

Один экземпляр View Model связан с одним View

Реализация:

При использовании этого паттерна, View не реализует соответствующий интерфейс. View должно иметь ссылку на источник данных, которым в данном случае является View Model. Элементы View связаны (bind) с соответствующими свойствами и событиями View Model. В свою очередь, View Model реализует специальный интерфейс, который используется для автоматического обновления элементов View

## Model-View-Controller:
Основная идея в том, что Controller и View зависят от Model, но Model никак не зависит от этих двух компонентов

Признаки Controll:

Controller определяет какой View доложно быть отображено в данный момент

События View могут повлиять только на Controller, Controller может повлиять на Model и определить другое View

Возможно несколько View для одного Controller

Реализация:

Controller перехватывает события из вне и в соответствии с заложенной в него логикой, реагирует на это событие изменяя Model, посредством вызова соответствующего метода. После изменения, Model использует событие, что она изменилась, и все подписанные на это события View, получив его, обращаются к Model за обновлёнными данными, после чего их отображают


## Резюме:
Реализация MVVM и MVP паттернов на первый взгляд выглядит достаточно схожей, однако, для MVVM связывание View с View Model осуществляется автоматически, а для MVP – необходимо программировать. MVC, по видимому, имеет больше возможностей по управлению View

## Общие правила выбора паттерна:
MVVM: используется в ситуации, когда возможно связывание данных без необходимости ввода специальных интерфейсов View

MVP: используется в ситуации, когда невозможно связывание данных

MVC: используется в ситуации, когда связь между View и другими частями приложения невозможна (и я не могу использовать MVVM или MVP)
# Gradle
## Об Gradle
Gradle – система автоматической сборки проекта

Файлы Gradle лежат в отдельной папке Gradle Script

Какие файлы содержит Gradle:

Файл build.gradle (для модуля) содержит следующие настройки: версия приложения, версия SDK и т.д.

Файл build.gradle (для проекта) содержит следующие настройки: настройки для репозиториев, настройки Gradle

# Android Architecture Components
Android Architecture Components – ряд вспомогательных библиотек, которые помогут с проектированием, тестированием и сопровождением приложений

Android Architecture Components можно разделить на четыре блока: Lifecycle, LiveData, ViewModel, Room Persistence

## Lifecycle
Lifecycle – упрощает работу с жизненным циклом приложения

Lifecycle можно разделить на два блока: Lifecycle Owner, Lifecycle Observer

# Android SDK
Android Studio – использует Android SDK, а также дополнительные инструменты (такие как графический дизайнер, отладчик, профилировщик и другие; удобный интерфейс для разработки Android приложений)

Android SDK – это набор компонентов, которые нужны разработчику, чтобы начать программировать приложения для Android

Android SDK tools – это один из компонентов Android SDK; он управляет Android SDK (обновляет её, обновляет пакеты и компоненты) и содержит множество других инструментов

Android SDK build tools – это подмножество Android SDK tools; содержит инструменты, которые необходимы для компиляции и отладки приложения (взаимодействие с приложением)

Android SDK platform tools – это подмножество Android SDK tools; предназначены для отладки и управления устройствами и эмуляторами (взаимодействие с устройствами и эмуляторами)

Android Support Library – включает в себя компоненты, такие как виджеты, функции управления жизненным циклом, инструменты для работы со стилями и темами, инструменты для работы с фрагментами, и многое другое

AndroidX – это набор библиотек для разработки приложений на Android, которые являются заменой для Android Support Library

Google APIs – набор API, которые позволяют интегрировать функциональность Google приложений в моё приложение

Google Play Services API – набор API из Google APIs, которые позволяют интегрировать фукнциональность Google в моё приложение

Google Play Services framework – хз

Android KTX – библиотека, которая предоставляет простые и удобные методы для работы с Android APIs

# Термины
API, пакеты, коллекции, фреймворки, библиотеки, архитектура

API – набор правил протоколов и технологий, которые позволяют одной программе взаимодействовать с другой программой

Пакет – группа логически связанных файлов; папка на диске

Библиотека – набор пакетов и классов (не накладывает на архитектуру приложения никаких ограничений; даёт полную свободу действий для программиста); это как плита

Фреймворк – набор пакетов и классов (накладывает на архитектуру приложения свои ограничения; накладывает ограничения, но избавляет от проблем с реализацией каркаса приложения и позволяет сосредоточиться на бизнес логике приложения); это как кухня

Коллекция – поставляемый с языком набор библиотек

Архитектура приложения – позволяет строить приложение по заранее выбраному паттерну проектирования (архитектура приложения это результат применения принципов и патернов проектирования и других элементов используемых в приложении)

Inversion of control – принцип проектирования, суть которого в том, что объект не создаёт сам для себя объекты, а принимает их из вне

Dependency injection – паттерн проектирования в Inversion of control; фреймворк

Dependency injection container – инструмент, который помогает реализовать паттерн dependency injection (например, Dagger или Koin)

Прицип проектирования – это общие правила для проектирования (например, KISS, SOLID, DRY)

Паттерн проектирования – это конкретный способ реализации одного из принципов проектирования

Архитектура приложения – позволяет строить приложение по заранее выбраному шаблону (чтобы повысить читаемость кода, вследствии чего его легко будет расширять, легко будет тестировать)
# ------
# GIT
## GIT основы
Файл, папка, ветка, коммит, тег, репозиторий (локальный, удалённый), .gitignore, readme.md, настройки

(ещё есть хеш, ссылка на репозиторий, имя ссылки на репозиторий)

Команда для того места где я СЕЙЧАС нахожусь, команда для СТАРОГО чего-либо (коммита, ветки, файла, тега)

Обращение по имени и по SHA-хешу

Все алиасы будут в виде jjимя\_алиаса (al = комманда в гит)

Добавить инфу, что значат цвета в гит баше

Работа в локальном репозитории (init, add, commit, mv, rm):

git init – инициализирует репозиторий в текущей директории

git add имя – добавление в индекс (можно указать имя, или папку; можно указать несколько значений)

git commit -m “комментарий” – делает снимок всех индексируемых файлов и папок и сохраняет в лок. репозитории

git mv что\_и\_откуда куда – перемещает файл; команда git add для нового файла и git rm для старого файла

git rm --cached файл – удаляет файл из индекса

git rm файл – удаляет файл из индекса и из файловой системы

git tag имя\_тега – создаёт новый тег на последний коммит в текущем репозитории

git tag -a имя\_тега -m “комментарий”- создаёт новый тег на последнем коммите в текущем репозитории

(аннотируемый тег содержит имя создателя, адрес электронной почты, дату и комментарий)

git tag -d имя – удаление тега

Осмотр в локальном репозитории:

git status – показывает изменённые индексируемые, все неиндексируемые и изменённые игнорируемые файлы

(также показывает имя текущей ветки)

git log – показывает историю коммитов от самого нового, к самому старому

(показывает историю текущей ветки)

git shortlog – показывает историю коммитов сгруппированных по автору

git describe – показывает список тегов и информацию о них

git show имя\_коммита\_или\_тега – показывает изменения, которые были сделаны в коммите или теге

git blame имя\_файла – показывает изменения, которые были сделаны в файле и кто их сделал

git tag – показывает список тегов в текущем репозитории

git tag -l шаблон\_подстановки – показать теги исходя из определённого шаблона

С checkout можно перемещаться по веткам, по коммитам, по тегам

Я могу посмотреть состояние репозитория по тегу через команду checkout

Команды ветвления:

Основная ветка в каждом репозитории называется master

git branch имя – создать ещё одну ветку с заданым именем (будет создана точная копия ветки master)

git checkout -b название\_ветки – то же самое, что и команда выше, только сразу происходит переключение на новую ветку

git branch – показывает список веток в репозитории

git checkout имя¬\_ветки – переключиться на другую ветку с заданным именем

git merge имя\_ветки – объединяет ветку, которую мы указали с веткой, в которой мы сейчас находимся (перед тем как сливать новый merge, следует обновить локальную ветку из сервера, во избежания дальнейших проблем, например, если мы хотим слить ветку с веткой master, то сначала нужно обновить ветку master)

git branch -d имя\_ветки – удалить ветку с указанным именем локально



как сменить название ветки

различные параметры для команд, использовать команды на практике, про команду bisect, grep

команды по отладке

как отменить коммит на сервере

как изменить комментарий в уже сделанном коммите

как посмотреть какие ссылки добавлены в git

научится сливать ветки

## GIT термины
GIT – консольная утилита, для отслеживания и ведения истории изменения файлов, в вашем проекте

Коммит – делает снимок состояния проекта на текущий момент

Коммит всегда делается в локальное хранилище

Каждый коммит содержит в себе всё содержимое файла (а не только различия между файлами)

Блоб – это отдельный файл в коммите

Ветка – хранилище для коммитов (ветку образуют коммиты); цепочка коммитов, которые идут друг за другом, у ветки есть название, основную ветку чаще всего называют mastrer (иногда main), если говорить простыми словами, то ветка master это наш проект

Другие ветки это отдельное место для реализации нового функционала, исправления багов, с отдельной веткой можно делать всё что угодно, а потом сливать эти изменения в основную ветку master

В разных ветках хранятся отдельные истории коммитов

Репозиторий – хранилище, где хранятся какие-либо данные

В GITе все действия всегда происходят локально, только если мы явно не укажем гиту работать с сервером

HEAD – указатель на текущую ветку

Тег – по сути, закладка на коммит, ссылка на соответствующий коммит

## GIT первая настройка
Первая настройка локального GITа:

Нужно ввести имя: git config --global user.name "ваше\_имя"

Нужно ввести почту: git config --global user.email "адрес\_почты@email.com"

Нужно указать GITу какую папку мы хотим отслеживать: переходим в корень папки и создаём там репозиторий

Чтобы создать локальный репозиторий для папки нужна следующая комнда: git init

Чтобы сохранить всю папку в локальный репозиторий GITа (сделать коммит) нужно начать отслеживать файлы:

Команда для отслеживанию всей папки: git add . или git add –all

Команда для отслеживания только отдельных файлов: git add имя\_файла

Команда для создания коммита и комментария к коммиту: git commit -m “комментарий”

Настройка визуальной составляющей GITа:

git config --global color.ui true

git config --global color.status auto

git config --global color.branch auto

## GIT как сделать
### Как авторизоваться в Git в GitHub:
Нужно ввести данные name и email такие же как в GitHub:

git config --global user.name “staskokoc”

git config --global user.email “staskokoc@gmail.com”

### Как подключиться к репозиторию GitHub:
(чтобы подключиться к удалённому репозиторию нужно сначала создать локальный репозиторий, git init)

Даём имя удалённому репозиторию (origin):

git remote add origin https://github.com/tutorialzine/awesome-project.git

### Как скачать файлы из удалённого репозитория
git pull origin master – скачивает файлы из удалённого репозитория из ветки master в локальный репозиторий в ветку, в которой я нахожусь

### Как сделать коммит
Нужно добавить файл в индексацию (git add имя\_файла)

Сделать коммит (commit -m “комментарий”)

### Как отправить коммит на сервер
git push адрес\_удалённого\_репозитория имя\_ветки – связывается с удалённым репозиторием, вычисляет локальные изменения, которые отсутствуют в удалённом репозитории, выгружает изменения на сервер в указанную ветку


### Как локальный репозиторий залить на гитхаб
Сначала нужно создать в гитхабе репозиторий для него (через браузер)

git remote add origin адрес созданного репозитория

Добавить всю папку в индексацию git add .

Сделать коммит (commit -m “комментарий”)

Отправить коммит на сервер git push имя\_удалённого\_репозитория имя\_ветки

### Полезные команды
git fetch – связывается с удалённым сервером и забирает из него всего изменения, которых у меня пока нет

git pull – работает как комбинация команд git fetch и git merge; вначале забирает изменения из указанного удалённого репозитория, а затем пытается их слить с локальными ветками

git pull адрес\_репозитория имя\_ветки – то же самое, только для какой-то одной ветки

git push адрес\_удалённого\_репозитория имя\_ветки – связывается с удалённым репозиторием, вычисляет локальные изменения, которые отсутствуют в удалённом репозитории, выгружает изменения на сервер в указанную ветку

git remote – позволяет сохранять длинные URL репозиториев в виде понятных строк

git clone адрес\_репозитория – создаёт копию удалённого  хранилища

git checkout идентификатор\_нужного\_коммита имя\_файла – позволяет вернуть выбранный файл к состоянию на момент определённого коммита

git status – показывает текущее состояние ветки (какие файлы добавлены или не добавлены для создания commit; какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе)

git log – показывает список всех коммитов и их идентификаторов

git mv – перемещает файл, а затем git add для нового файла и git rm для старого файла

git rm имя\_файла – удаляет файл из отслеживания и из рабочей директории (удалять файлы из проекта следует с помощью этой команды)

git reset --hard хеш\_коммита – позволяет откатиться к указанному коммиту

git clean (удаляет неиндексированные файлы):

git clean -n – показать файлы, которые будут удалены

git clean -f – будут удалены все неиндексированные файлы (кроме файлов и папок указаных в .gitignore)

git clean -df – будут удалены все все неиндексированные файлы и папки (кроме файлов и папок указаных в .gitignore)

git clean xf – удалить все неиндексированные файлы и файлы в .gitignore

git clean xdf – удалить все неиндексированные файлы и папки, и в .gitignore в том числе

git clean -i – интерактивный режим удаления (чтобы выйти quit)

git tag – показывает список тегов в репозитории

git tag имя\_тега – создаёт облегчённый тег с указанным именем (облегчённый тег не содержит никакой информации, кроме имени тега)

git tag -a имя\_тега -m “комментарий”- создаёт аннотируемый тег с указанным именем (аннотируемый тег содержит имя создателя, адрес электронной почты и дату) и комментарием

git tag -l шаблон\_подстановки – показать теги исходя из определённого шаблона

## Readme.md
Readme.md – содержит в себе описание проекта

Readme.md находится в корне папки

Readme.md использует язык разметки markdown

## .gitignore
Файл .gitignore:

Файл .gitignore нужно вручную создать в корне репозитория (можно и в другом месте, но приняно в корне)

Файлы, которые нужно игнорировать нужно вручную добавлять в файл .gitignore

Затем нужно его добавить его местоположение в настройках (данные настройки глобальны, применяются для всех проектов):

git config --global core.excludesFile путь\_к\_корню\_проекта/.gitignore

Git рассматривает каждый файл как:

Отслеживаемый файл – индексируемый; файл, который был предварительно проиндексирован (git add)

Неотслеживаемый файл – неиндексируемый; файл, который не был предварительно проиндексирован (git ignore)

Игнорируемый файл – указан в .gitignore; файл, который необходимо игнорировать; файлы, которые нужны, но которые не должны попадать в коммиты

.gitignore поддерживает шаблоны подстановки: 

/ – означает каталог, в котором находится .gitignore

\# – означает комментарий

\*\*/logs – означает, что будут игнорированы папки logs в любом месте репозитория

В файле .git/info/exclude можно задать собственные настройки игнорирования, которые никогда не будут закоммичены, этот файл будет храниться только локально в этом месте и работать только для того репозитория, в котором он находится

Как добавть файл в .gitignore, который уже был закоммичен:

Сначала нужно удалить его из репозитория: git rm --cached

Затем нужно добавить его в .gitignore

Как принудительно закоммитить файл, который был добавлен в .gitignore:

Или можно добавить для этого файла исключение в .gitignore

Или можно выполнить команду: git add -f имя\_файла

Команды:

git check-ignore -v имя\_файла – определяет какой шаблон приводит к игнорированию файла

## .gitconfig
[user]

`    `name = “staskokoc”

`    `email = staskokoc@gmail.com

[diff]

`    `tool = meld

[difftool]

`    `prompt = false

[difftool "meld"]

`    `cmd = meld $LOCAL $REMOTE

[merge]

`    `tool = meld

[mergetool "meld"]

`    `prompt = false

`    `keepBackup = true

`    `cmd = meld "$LOCAL" "$MERGED" "$REMOTE" --output="$MERGED"

[alias]

`    `df = difftool --dir-diff

`    `mt = mergetool -t meld

# ------
# Вопросы на собеседовании
## Что такое ООП?
Объектно-ориентированное программирование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

\1. Объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;

\2. Каждый объект является экземпляром определенного класса

\3. Классы образуют иерархии.

Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние.
## Какие основые принципы ООП?
\1. Инкапсуляция - сокрытие реализации.

\2. Наследование - создание новой сущности на базе уже существующей.

\3. Полиморфизм - возможность иметь разные формы для одной и той же сущности.

\4. Абстракция - набор общих характеристик.

\5. Посылка сообщений - форма связи, взаимодействия между сущностями.

\6. Переиспользование - все что перечислено выше работает на повторное использование кода.

Это единственно верный порядок парадигм ООП, так как каждая последующая использует предыдущие.
## Что такое инкапсуляция?
Инкапсуляция – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании.

Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.

Пример 1:

Представим на минутку, что мы оказались в конце позапрошлого века, когда Генри Форд ещё не придумал конвейер, а первые попытки создать автомобиль сталкивались с критикой властей по поводу того, что эти коптящие монстры загрязняют воздух и пугают лошадей. Представим, что для управления первым паровым автомобилем необходимо было знать, как устроен паровой котёл, постоянно подбрасывать уголь, следить за температурой, уровнем воды. При этом для поворота колёс использовать два рычага, каждый из которых поворачивает одно колесо в отдельности. Думаю, можно согласиться с тем, что вождение автомобиля того времени было весьма неудобным и трудным занятием.

Теперь вернёмся в сегодняшний день к современным чудесам автопрома с коробкой-автоматом. На самом деле, по сути, ничего не изменилось. Бензонасос всё так же поставляет бензин в двигатель, дифференциалы обеспечивают поворот колёс на различающиеся углы, коленвал превращает поступательное движение поршня во вращательное движение колёс. Прогресс в другом. Сейчас все эти действия скрыты от пользователя и позволяют ему крутить руль и нажимать на педаль газа, не задумываясь, что в это время происходит с инжектором, дроссельной заслонкой и распредвалом. Именно сокрытие внутренних процессов, происходящих в автомобиле, позволяет эффективно его использовать даже тем, кто не является профессионалом-автомехаником с двадцатилетним стажем. Это сокрытие в ООП носит название инкапсуляции.

Пример 2:

|class SomePhone(val year: Int, val company: String) {<br>`    `private fun openConnection() {<br>`        `// findComutator<br>`        `// openNewConnection...<br>`    `}<br>`    `public fun call() {<br>`        `openConnection()<br>`        `*println*("Введите номер")<br>`    `}<br>`    `public fun ring() {<br>`        `*println*("Дзынь-дзынь")<br>`    `}<br>}|
| :- |

Модификатор private делает доступными поля и методы класса только внутри данного класса. Это означает, что получить доступ к private полям из вне невозможно, как и нет возможности вызвать private методы.

Сокрытие доступа к методу openConnection, оставляет нам также возможность к свободному изменению внутренней реализации этого метода, так как этот метод гарантированно не используется другими объектами и не нарушит их работу.

Для работы с нашим объектом мы оставляем открытыми методы call и ring с помощью модификатора public. Предоставление открытых методов для работы с объектом также является частью механизма инкапсуляции, так как если полностью закрыть доступ к объекту – он станет бесполезным.
## Что такое наследование?
Наследование – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется предком, базовым, родительским или суперклассом. Новый класс – потомком, производным, наследником или подклассом.

Пример 1:

Представим себя, на минуту, инженерами автомобильного завода. Нашей задачей является разработка современного автомобиля. У нас уже есть предыдущая модель, которая отлично зарекомендовала себя в течение многолетнего использования. Всё бы хорошо, но времена и технологии меняются, а наш современный завод должен стремиться повышать удобство и комфорт выпускаемой продукции и соответствовать современным стандартам.

Нам необходимо выпустить целый модельный ряд автомобилей: седан, универсал и малолитражный хэтч-бэк. Очевидно, что мы не собираемся проектировать новый автомобиль с нуля, а, взяв за основу предыдущее поколение, внесём ряд конструктивных изменений. Например, добавим гидроусилитель руля и уменьшим зазоры между крыльями и крышкой капота, поставим противотуманные фонари. Кроме того, в каждой модели будет изменена форма кузова.

Очевидно, что все три модификации будут иметь большинство свойств прежней модели (старый добрый двигатель 1970 года, непробиваемая ходовая часть, зарекомендовавшая себя отличным образом на отечественных дорогах, коробку передач и т.д.). При этом каждая из моделей будет реализовать некоторую новую функциональность или конструктивную особенность. В данном случае, мы имеем дело с наследованием.

Пример 2:

Рассмотрим пример создания класса смартфон с помощью наследования. Все беспроводные телефоны работают от аккумуляторных батарей, которые имеют определенный ресурс работы в часах. Поэтому добавим это свойство в класс беспроводных телефонов:

|abstract class AbstractPhone(val year: Int)<br>abstract class WirelessPhone(year: Int, val hour: Int): AbstractPhone(year)|
| :- |

Сотовые телефоны наследуют свойства беспроводного телефона, мы также добавили в этот класс реализацию методов call и ring:

|abstract class CellPhone(year: Int, hour: Int): WirelessPhone(year, hour) {<br>`    `override fun call(outputNumber: Int) {<br>`        `*println*("Вызываю номер ${outputNumber}")<br>`    `}<br>`    `override fun ring(inputNumber: Int) {<br>`        `*println*("Вам звонит абонент ${inputNumber}")<br>`    `}<br>}|
| :- |

И, наконец, класс смартфон, который в отличие от классических сотовых телефонов имеет полноценную операционную систему. В смартфон можно добавлять новые программы, поддерживаемые данной операционной системой, расширяя, таким образом, его функциональность. С помощью кода класс можно описать так:

|class SmartPhone(year: Int, hour: Int, val operationSystem: Int): CellPhone(year, hour) {<br>`    `fun install(program: String) {<br>`        `*println*("Устанавливаю ${program} для ${operationSystem}")<br>`    `}<br>}|
| :- |

Как видите, для описания класса Smartphone мы создали совсем немного нового кода, но получили новый класс с новой функциональностью. Использование этого принципа ООП java позволяет значительно уменьшить объем кода, а значит, и облегчить работу программисту.
## Что такое полиморфизм?
Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).

Пример 1:

Любое обучение вождению не имело бы смысла, если бы человек, научившийся водить, скажем, ВАЗ 2106 не мог потом водить ВАЗ 2110 или BMW X3. С другой стороны, трудно представить человека, который смог бы нормально управлять автомобилем, в котором педаль газа находится левее педали тормоза, а вместо руля – джойстик.

Всё дело в том, что основные элементы управления автомобиля имеют одну и ту же конструкцию и принцип действия. Водитель точно знает, что для того, чтобы повернуть налево, он должен повернуть руль, независимо от того, есть там гидроусилитель или нет. Если человеку надо доехать с работы до дома, то он сядет за руль автомобиля и будет выполнять одни и те же действия, независимо от того, какой именно тип автомобиля он использует. По сути, можно сказать, что все автомобили имеют один и тот же интерфейс, а водитель, абстрагируясь от сущности автомобиля, работает именно с этим интерфейсом. Если водителю предстоит ехать по немецкому автобану, он, вероятно выберет быстрый автомобиль с низкой посадкой, а если предстоит возвращаться из отдалённого маральника в Горном Алтае после дождя, скорее всего, будет выбран УАЗ с армейскими мостами. Но, независимо от того, каким образом будет реализовываться движение и внутреннее функционирование машины, интерфейс останется прежним.

Полиморфная переменная, это переменная, которая может принимать значения разных типов, а полиморфная функция, это функция, у которой хотя бы один аргумент является полиморфной переменной. Выделяют два вида полиморфных функций:

\- ad hoc, функция ведет себя по разному для разных типов аргументов (например, функция draw() — рисует по разному фигуры разных типов);

\- параметрический, функция ведет себя одинаково для аргументов разных типов (например, функция add() — одинаково кладет в контейнер элементы разных типов).

Принцип в ООП, когда программа может использовать объекты с одинаковым интерфейсом без информации о внутреннем устройстве объекта, называется полиморфизмом.

Пример 2:

Давайте представим, что нам в программе нужно описать пользователя, который может пользоваться любыми моделями телефона, чтобы позвонить другому пользователю. Вот как можно это сделать:

|abstract class AbstractPhone(val year: Int) {<br>`    `abstract fun call(outputNumber: Int)<br>`    `abstract fun ring(inputNumber: Int)<br>}<br><br>class User(val name: String) {<br>`    `fun callAnotherUser(number: Int, phone: AbstractPhone) {<br>`        `// вот он полиморфизм - использование в коде абстрактного типа AbstractPhone phone<br>`        `phone.call(number)<br>`    `}<br>}|
| :- |

Теперь опишем различные модели телефонов. Одна из первых моделей телефонов:

|class ThomasEdisonPhone(year: Int): AbstractPhone(year) {<br>`    `override fun call(outputNumber: Int) {<br>`        `*println*("Вращайте ручку")<br>`        `*println*("Сообщите номер абонента, сэр")<br>`    `}<br>`    `override fun ring(inputNumber: Int) {<br>`        `*println*("Телефон звонит")<br>`    `}<br>}|
| :- |

Обычный стационарный телефон:

![](Aspose.Words.03b2346a-e53d-439c-8d4c-28410946bacc.003.png)

И, наконец, крутой видеотелефон:

![](Aspose.Words.03b2346a-e53d-439c-8d4c-28410946bacc.004.png)

Создадим объекты в методе main() и протестируем метод callAnotherUser:

![](Aspose.Words.03b2346a-e53d-439c-8d4c-28410946bacc.005.png)

Используя вызов одного и того же метода объекта user, мы получили различные результаты. Выбор конкретной реализации метода call внутри метода callAnotherUser производился динамически на основании конкретного типа вызывающего его объекта в процессе выполнения программы. В этом и заключается основное преимущество полиморфизма – выбор реализации в процессе выполнения программы.

В примерах классов телефонов, приведенных выше, мы использовали переопределение методов – прием, при котором изменяется реализация метода, определенная в базовом классе, без изменения сигнатуры метода. По сути, это является заменой метода, и именно новый метод, определенный в подклассе, вызывается при выполнении программы.

Обычно, при переопределении метода, используется аннотация @Override, которая подсказывает компилятору о необходимости проверить сигнатуры переопределяемого и переопределяющего методов.
## Что такое абстракция?
Абстрагирование – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые. Соответственно, абстракция – это набор всех таких характеристик.

Пример 1:

Представьте, что водитель едет в автомобиле по оживлённому участку движения. Понятно, что в этот момент он не будет задумываться о химическом составе краски автомобиля, особенностях взаимодействия шестерёнок в коробке передач или влияния формы кузова на скорость (разве что, автомобиль стоит в глухой пробке и водителю абсолютно нечем заняться). Однако, руль, педали, указатель поворота он будет использовать регулярно.

Пример 2:

![](Aspose.Words.03b2346a-e53d-439c-8d4c-28410946bacc.006.png)
## Что представляет собой обмен сообщениями?
Объекты взаимодействуют, посылая и получая сообщения. Сообщение — это запрос на выполнение действия, дополненный набором аргументов, которые могут понадобиться при выполнении действия. В ООП посылка сообщения (вызов метода) — это единственный путь передать управление объекту. Если объект должен «отвечать» на это сообщение, то у него должна иметься соответствующий данному сообщению метод. Так же объекты, используя свои методы, могут и сами посылать сообщения другим объектам. Обмен сообщениями реализуется с помощью динамических вызовов, что приводит к чрезвычайно позднему связыванию (extreme late binding).

Пример 1:

Пусть требуется создать физическую модель, описывающую сталкивающиеся шары разных размеров. Традиционный подход к решению этой задачи примерно таков: определяется набор данных, описывающих каждый шар (например, его координаты, массу и ускорение); каждому шару присваивается уникальный идентификатор (например, организуется массив, значение индекса которого соответствует номеру шара), который позволит отличать каждый из шаров от всех других. Наконец, пишется подпрограмма с названием, скажем, bounce; эта процедура должна на основе номера шара и его начальных параметров соответствующим образом изменять данные, описывающие шар. В отличие от традиционного подхода объектно-ориентированная версия программы моделирует каждый из шаров посредством объекта. При этом объект, соответствующий конкретному шару, содержит не только его параметры, но и весь код, описывающий поведение шара при различных взаимодействиях. Так, каждый шар будет иметь собственный метод bounce(). Вместо того, чтобы вызывать подпрограмму bounce с аргументом, определяющим, скажем, шар №3, необходимо будет передать объекту «шар №3» сообщение, предписывающее ему выполнить столкновение.
## В чем заключаются преимущества и недостатки объектно-ориентированного подхода в программировании?
Преимущества:

\1. Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человеческое восприятие мира, а не на компьютерную реализацию.

\2. Классы позволяют проводить конструирование из полезных компонентов, обладающих простыми инструментами, что позволяет абстрагироваться от деталей реализации.

\3. Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает в случае процедурного программирования, а описываются вместе. Локализация кода и данных улучшает наглядность и удобство сопровождения программного обеспечения.

\4. Инкапсуляция позволяет привнести свойство модульности, что облегчает распараллеливание выполнения задачи между несколькими исполнителями и обновление версий отдельных компонентов.

\5. Возможность создавать расширяемые системы.

\6. Использование полиморфизма оказывается полезным при:

6.1. Обработке разнородных структур данных. Программы могут работать, не различая вида объектов, что существенно упрощает код. Новые виды могут быть добавлены в любой момент.

6.2. Изменении поведения во время исполнения. На этапе исполнения один объект может быть заменен другим, что позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.

6.3. Реализации работы с наследниками. Алгоритмы можно обобщить настолько, что они уже смогут работать более чем с одним видом объектов.

6.4. Возможности описать независимые от приложения части предметной области в виде набора универсальных классов, или фреймворка, который в дальнейшем будет расширен за счет добавления частей, специфичных для конкретного приложения.

\7. Повторное использование кода:

7.1. Сокращается время на разработку, которое может быть отдано другим задачам.

7.2. Компоненты многоразового использования обычно содержат гораздо меньше ошибок, чем вновь разработанные, ведь они уже не раз подвергались проверке.

7.3. Когда некий компонент используется сразу несколькими клиентами, улучшения, вносимые в его код, одновременно оказывают положительное влияние и на множество работающих с ним программ.

7.4. Если программа опирается на стандартные компоненты, ее структура и пользовательский интерфейс становятся более унифицированными, что облегчает ее понимание и упрощает использование.

Недостатки:

\1. В сложных иерархиях классов поля и методы обычно наследуются с разных уровней. И не всегда легко определить, какие поля и методы фактически относятся к данному классу.

\2. Код для обработки сообщения иногда «размазан» по многим методам (иначе говоря, обработка сообщения требует не одного, а многих методов, которые могут быть описаны в разных классах).

\3. Документирование классов - задача более трудная, чем это было в случае процедур и модулей. Поскольку любой метод может быть переопределен, в документации должно говориться не только о том, что делает данный метод, но и о том, в каком контексте он вызывается.

\4. Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).

\5. Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.
## Что подразумевают в плане принципов ООП выражения «является» и «имеет»?
«Является» - подразумевает наследование. «Имеет» - подразумевает ассоциацию (агрегацию или композицию).
## В чем разница между композицией и агрегацией?
Ассоциация обозначает связь между объектами. Композиция и агрегация — частные случаи ассоциации «часть-целое».

Агрегация предполагает, что объекты связаны взаимоотношением «part-of» (часть). Композиция более строгий вариант агрегации. Дополнительно к требованию «part-of» накладывается условие, что экземпляр «части» может входить только в одно целое (или никуда не входить), в то время как в случае агрегации экземпляр «части» может входить в несколько целых.

Пример 1:

Например, книга состоит из страниц, и мы не можем вырвать страницу из книги и вложить в другую книгу. Страницы четко привязаны к конкретной книге, поэтому это композиция. В тоже время мы можем взять и перенести книгу из одной библиотеки в другую - это уже агрегация.

Пример 2. Композиция:

Композиция – это когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.

![](Aspose.Words.03b2346a-e53d-439c-8d4c-28410946bacc.007.png)

Пример 3. Агрегация:

Агрегация – это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра:

![](Aspose.Words.03b2346a-e53d-439c-8d4c-28410946bacc.008.png)


